// Code generated by protoc-gen-gogo.
// source: vo.proto
// DO NOT EDIT!

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 玩家的详细数据
type UserData struct {
	Userid     string    `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname   string    `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Phone      string    `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Sex        uint32    `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Photo      string    `protobuf:"bytes,5,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin       uint32    `protobuf:"varint,6,opt,name=coin,proto3" json:"coin,omitempty"`
	Diamond    uint32    `protobuf:"varint,7,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Roomtype   uint32    `protobuf:"varint,8,opt,name=roomtype,proto3" json:"roomtype,omitempty"`
	Roomid     string    `protobuf:"bytes,9,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Invitecode string    `protobuf:"bytes,10,opt,name=invitecode,proto3" json:"invitecode,omitempty"`
	Agent      string    `protobuf:"bytes,11,opt,name=agent,proto3" json:"agent,omitempty"`
	Give       uint32    `protobuf:"varint,12,opt,name=give,proto3" json:"give,omitempty"`
	Bank       uint32    `protobuf:"varint,13,opt,name=bank,proto3" json:"bank,omitempty"`
	Data       *Activity `protobuf:"bytes,14,opt,name=data" json:"data,omitempty"`
	Vip        *VipInfo  `protobuf:"bytes,15,opt,name=vip" json:"vip,omitempty"`
}

func (m *UserData) Reset()                    { *m = UserData{} }
func (*UserData) ProtoMessage()               {}
func (*UserData) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{0} }

func (m *UserData) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *UserData) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *UserData) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *UserData) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *UserData) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *UserData) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *UserData) GetDiamond() uint32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *UserData) GetRoomtype() uint32 {
	if m != nil {
		return m.Roomtype
	}
	return 0
}

func (m *UserData) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *UserData) GetInvitecode() string {
	if m != nil {
		return m.Invitecode
	}
	return ""
}

func (m *UserData) GetAgent() string {
	if m != nil {
		return m.Agent
	}
	return ""
}

func (m *UserData) GetGive() uint32 {
	if m != nil {
		return m.Give
	}
	return 0
}

func (m *UserData) GetBank() uint32 {
	if m != nil {
		return m.Bank
	}
	return 0
}

func (m *UserData) GetData() *Activity {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UserData) GetVip() *VipInfo {
	if m != nil {
		return m.Vip
	}
	return nil
}

type UserInfo struct {
	Userid   string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname string `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Phone    string `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Sex      uint32 `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Photo    string `protobuf:"bytes,5,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin     uint32 `protobuf:"varint,6,opt,name=coin,proto3" json:"coin,omitempty"`
	Diamond  uint32 `protobuf:"varint,7,opt,name=diamond,proto3" json:"diamond,omitempty"`
}

func (m *UserInfo) Reset()                    { *m = UserInfo{} }
func (*UserInfo) ProtoMessage()               {}
func (*UserInfo) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{1} }

func (m *UserInfo) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *UserInfo) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *UserInfo) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *UserInfo) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *UserInfo) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *UserInfo) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *UserInfo) GetDiamond() uint32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

// 房间数据
type RoomInfo struct {
	Roomid string `protobuf:"bytes,1,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Rtype  uint32 `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Rname  string `protobuf:"bytes,3,opt,name=rname,proto3" json:"rname,omitempty"`
	Count  uint32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Ante   uint32 `protobuf:"varint,5,opt,name=ante,proto3" json:"ante,omitempty"`
	Chat   uint32 `protobuf:"varint,6,opt,name=chat,proto3" json:"chat,omitempty"`
}

func (m *RoomInfo) Reset()                    { *m = RoomInfo{} }
func (*RoomInfo) ProtoMessage()               {}
func (*RoomInfo) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{2} }

func (m *RoomInfo) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *RoomInfo) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *RoomInfo) GetRname() string {
	if m != nil {
		return m.Rname
	}
	return ""
}

func (m *RoomInfo) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *RoomInfo) GetAnte() uint32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *RoomInfo) GetChat() uint32 {
	if m != nil {
		return m.Chat
	}
	return 0
}

// 玩家的活动数据
type Activity struct {
	Firstpay  uint32 `protobuf:"varint,1,opt,name=firstpay,proto3" json:"firstpay,omitempty"`
	Relieve   uint32 `protobuf:"varint,2,opt,name=relieve,proto3" json:"relieve,omitempty"`
	Bankrupt  uint32 `protobuf:"varint,3,opt,name=bankrupt,proto3" json:"bankrupt,omitempty"`
	Prizedraw uint32 `protobuf:"varint,4,opt,name=prizedraw,proto3" json:"prizedraw,omitempty"`
	Leftdraw  uint32 `protobuf:"varint,5,opt,name=leftdraw,proto3" json:"leftdraw,omitempty"`
	Kicktimes uint32 `protobuf:"varint,6,opt,name=kicktimes,proto3" json:"kicktimes,omitempty"`
}

func (m *Activity) Reset()                    { *m = Activity{} }
func (*Activity) ProtoMessage()               {}
func (*Activity) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{3} }

func (m *Activity) GetFirstpay() uint32 {
	if m != nil {
		return m.Firstpay
	}
	return 0
}

func (m *Activity) GetRelieve() uint32 {
	if m != nil {
		return m.Relieve
	}
	return 0
}

func (m *Activity) GetBankrupt() uint32 {
	if m != nil {
		return m.Bankrupt
	}
	return 0
}

func (m *Activity) GetPrizedraw() uint32 {
	if m != nil {
		return m.Prizedraw
	}
	return 0
}

func (m *Activity) GetLeftdraw() uint32 {
	if m != nil {
		return m.Leftdraw
	}
	return 0
}

func (m *Activity) GetKicktimes() uint32 {
	if m != nil {
		return m.Kicktimes
	}
	return 0
}

// vip
type VipInfo struct {
	Level  uint32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Number uint32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *VipInfo) Reset()                    { *m = VipInfo{} }
func (*VipInfo) ProtoMessage()               {}
func (*VipInfo) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{4} }

func (m *VipInfo) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *VipInfo) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 玩家的基础数据
type RoomUser struct {
	Userid   string     `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname string     `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Phone    string     `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Sex      uint32     `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Photo    string     `protobuf:"bytes,5,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin     uint32     `protobuf:"varint,6,opt,name=coin,proto3" json:"coin,omitempty"`
	Diamond  uint32     `protobuf:"varint,7,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Seat     uint32     `protobuf:"varint,8,opt,name=seat,proto3" json:"seat,omitempty"`
	Ready    bool       `protobuf:"varint,9,opt,name=ready,proto3" json:"ready,omitempty"`
	Score    int32      `protobuf:"varint,10,opt,name=score,proto3" json:"score,omitempty"`
	Dealer   uint32     `protobuf:"varint,11,opt,name=dealer,proto3" json:"dealer,omitempty"`
	Bet      uint32     `protobuf:"varint,12,opt,name=bet,proto3" json:"bet,omitempty"`
	Cards    []uint32   `protobuf:"varint,13,rep,packed,name=cards" json:"cards,omitempty"`
	Num      uint32     `protobuf:"varint,14,opt,name=num,proto3" json:"num,omitempty"`
	Niu      bool       `protobuf:"varint,15,opt,name=niu,proto3" json:"niu,omitempty"`
	Vip      *VipInfo   `protobuf:"bytes,16,opt,name=vip" json:"vip,omitempty"`
	Value    uint32     `protobuf:"varint,17,opt,name=value,proto3" json:"value,omitempty"`
	Dan      *DanCombat `protobuf:"bytes,18,opt,name=dan" json:"dan,omitempty"`
}

func (m *RoomUser) Reset()                    { *m = RoomUser{} }
func (*RoomUser) ProtoMessage()               {}
func (*RoomUser) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{5} }

func (m *RoomUser) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomUser) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *RoomUser) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *RoomUser) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *RoomUser) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *RoomUser) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *RoomUser) GetDiamond() uint32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *RoomUser) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomUser) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *RoomUser) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RoomUser) GetDealer() uint32 {
	if m != nil {
		return m.Dealer
	}
	return 0
}

func (m *RoomUser) GetBet() uint32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *RoomUser) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *RoomUser) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *RoomUser) GetNiu() bool {
	if m != nil {
		return m.Niu
	}
	return false
}

func (m *RoomUser) GetVip() *VipInfo {
	if m != nil {
		return m.Vip
	}
	return nil
}

func (m *RoomUser) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *RoomUser) GetDan() *DanCombat {
	if m != nil {
		return m.Dan
	}
	return nil
}

// 房间数据
type RoomData struct {
	Roomid     string `protobuf:"bytes,1,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Rtype      uint32 `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Rname      string `protobuf:"bytes,3,opt,name=rname,proto3" json:"rname,omitempty"`
	Count      uint32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Ante       uint32 `protobuf:"varint,5,opt,name=ante,proto3" json:"ante,omitempty"`
	Chat       uint32 `protobuf:"varint,6,opt,name=chat,proto3" json:"chat,omitempty"`
	Expire     uint32 `protobuf:"varint,7,opt,name=expire,proto3" json:"expire,omitempty"`
	Invitecode string `protobuf:"bytes,8,opt,name=invitecode,proto3" json:"invitecode,omitempty"`
	Dealer     uint32 `protobuf:"varint,9,opt,name=dealer,proto3" json:"dealer,omitempty"`
	Round      uint32 `protobuf:"varint,10,opt,name=round,proto3" json:"round,omitempty"`
	Userid     string `protobuf:"bytes,11,opt,name=userid,proto3" json:"userid,omitempty"`
	State      uint32 `protobuf:"varint,12,opt,name=state,proto3" json:"state,omitempty"`
	Card       uint32 `protobuf:"varint,13,opt,name=card,proto3" json:"card,omitempty"`
	Xi         uint32 `protobuf:"varint,14,opt,name=xi,proto3" json:"xi,omitempty"`
	Draw       uint32 `protobuf:"varint,15,opt,name=draw,proto3" json:"draw,omitempty"`
	Discard    uint32 `protobuf:"varint,16,opt,name=discard,proto3" json:"discard,omitempty"`
	Seat       uint32 `protobuf:"varint,17,opt,name=seat,proto3" json:"seat,omitempty"`
	Number     uint32 `protobuf:"varint,18,opt,name=number,proto3" json:"number,omitempty"`
	Total      uint32 `protobuf:"varint,19,opt,name=total,proto3" json:"total,omitempty"`
	Players    uint32 `protobuf:"varint,20,opt,name=players,proto3" json:"players,omitempty"`
}

func (m *RoomData) Reset()                    { *m = RoomData{} }
func (*RoomData) ProtoMessage()               {}
func (*RoomData) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{6} }

func (m *RoomData) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *RoomData) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *RoomData) GetRname() string {
	if m != nil {
		return m.Rname
	}
	return ""
}

func (m *RoomData) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *RoomData) GetAnte() uint32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *RoomData) GetChat() uint32 {
	if m != nil {
		return m.Chat
	}
	return 0
}

func (m *RoomData) GetExpire() uint32 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *RoomData) GetInvitecode() string {
	if m != nil {
		return m.Invitecode
	}
	return ""
}

func (m *RoomData) GetDealer() uint32 {
	if m != nil {
		return m.Dealer
	}
	return 0
}

func (m *RoomData) GetRound() uint32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *RoomData) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomData) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *RoomData) GetCard() uint32 {
	if m != nil {
		return m.Card
	}
	return 0
}

func (m *RoomData) GetXi() uint32 {
	if m != nil {
		return m.Xi
	}
	return 0
}

func (m *RoomData) GetDraw() uint32 {
	if m != nil {
		return m.Draw
	}
	return 0
}

func (m *RoomData) GetDiscard() uint32 {
	if m != nil {
		return m.Discard
	}
	return 0
}

func (m *RoomData) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomData) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *RoomData) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *RoomData) GetPlayers() uint32 {
	if m != nil {
		return m.Players
	}
	return 0
}

// 下注信息
type RoomBets struct {
	Seat uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Bets uint32 `protobuf:"varint,2,opt,name=bets,proto3" json:"bets,omitempty"`
}

func (m *RoomBets) Reset()                    { *m = RoomBets{} }
func (*RoomBets) ProtoMessage()               {}
func (*RoomBets) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{7} }

func (m *RoomBets) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomBets) GetBets() uint32 {
	if m != nil {
		return m.Bets
	}
	return 0
}

// 玩家的基础数据
type FreeUser struct {
	Userid   string      `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname string      `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Phone    string      `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Sex      uint32      `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty"`
	Photo    string      `protobuf:"bytes,5,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin     uint32      `protobuf:"varint,6,opt,name=coin,proto3" json:"coin,omitempty"`
	Diamond  uint32      `protobuf:"varint,7,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Seat     uint32      `protobuf:"varint,8,opt,name=seat,proto3" json:"seat,omitempty"`
	Ready    bool        `protobuf:"varint,9,opt,name=ready,proto3" json:"ready,omitempty"`
	Bet      uint32      `protobuf:"varint,10,opt,name=bet,proto3" json:"bet,omitempty"`
	Bets     []*RoomBets `protobuf:"bytes,11,rep,name=bets" json:"bets,omitempty"`
	Vip      *VipInfo    `protobuf:"bytes,12,opt,name=vip" json:"vip,omitempty"`
}

func (m *FreeUser) Reset()                    { *m = FreeUser{} }
func (*FreeUser) ProtoMessage()               {}
func (*FreeUser) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{8} }

func (m *FreeUser) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *FreeUser) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *FreeUser) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *FreeUser) GetSex() uint32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *FreeUser) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *FreeUser) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *FreeUser) GetDiamond() uint32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *FreeUser) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *FreeUser) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *FreeUser) GetBet() uint32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *FreeUser) GetBets() []*RoomBets {
	if m != nil {
		return m.Bets
	}
	return nil
}

func (m *FreeUser) GetVip() *VipInfo {
	if m != nil {
		return m.Vip
	}
	return nil
}

// 房间数据
type FreeRoom struct {
	Roomid        string `protobuf:"bytes,1,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Rtype         uint32 `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Rname         string `protobuf:"bytes,3,opt,name=rname,proto3" json:"rname,omitempty"`
	Count         uint32 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Ante          uint32 `protobuf:"varint,5,opt,name=ante,proto3" json:"ante,omitempty"`
	Chat          uint32 `protobuf:"varint,6,opt,name=chat,proto3" json:"chat,omitempty"`
	Dealer        uint32 `protobuf:"varint,7,opt,name=dealer,proto3" json:"dealer,omitempty"`
	Userid        string `protobuf:"bytes,8,opt,name=userid,proto3" json:"userid,omitempty"`
	Coin          uint32 `protobuf:"varint,9,opt,name=coin,proto3" json:"coin,omitempty"`
	Pond          uint32 `protobuf:"varint,10,opt,name=pond,proto3" json:"pond,omitempty"`
	State         uint32 `protobuf:"varint,11,opt,name=state,proto3" json:"state,omitempty"`
	Timer         uint32 `protobuf:"varint,12,opt,name=timer,proto3" json:"timer,omitempty"`
	DealerNum     uint32 `protobuf:"varint,13,opt,name=dealerNum,proto3" json:"dealerNum,omitempty"`
	LeftDealerNum uint32 `protobuf:"varint,14,opt,name=leftDealerNum,proto3" json:"leftDealerNum,omitempty"`
	Photo         string `protobuf:"bytes,15,opt,name=photo,proto3" json:"photo,omitempty"`
}

func (m *FreeRoom) Reset()                    { *m = FreeRoom{} }
func (*FreeRoom) ProtoMessage()               {}
func (*FreeRoom) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{9} }

func (m *FreeRoom) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *FreeRoom) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *FreeRoom) GetRname() string {
	if m != nil {
		return m.Rname
	}
	return ""
}

func (m *FreeRoom) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FreeRoom) GetAnte() uint32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *FreeRoom) GetChat() uint32 {
	if m != nil {
		return m.Chat
	}
	return 0
}

func (m *FreeRoom) GetDealer() uint32 {
	if m != nil {
		return m.Dealer
	}
	return 0
}

func (m *FreeRoom) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *FreeRoom) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *FreeRoom) GetPond() uint32 {
	if m != nil {
		return m.Pond
	}
	return 0
}

func (m *FreeRoom) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *FreeRoom) GetTimer() uint32 {
	if m != nil {
		return m.Timer
	}
	return 0
}

func (m *FreeRoom) GetDealerNum() uint32 {
	if m != nil {
		return m.DealerNum
	}
	return 0
}

func (m *FreeRoom) GetLeftDealerNum() uint32 {
	if m != nil {
		return m.LeftDealerNum
	}
	return 0
}

func (m *FreeRoom) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

// 结算数据
type RoomOver struct {
	Seat  uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Cards []uint32 `protobuf:"varint,2,rep,packed,name=cards" json:"cards,omitempty"`
	Value uint32   `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	Total int32    `protobuf:"varint,4,opt,name=total,proto3" json:"total,omitempty"`
	Score int32    `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *RoomOver) Reset()                    { *m = RoomOver{} }
func (*RoomOver) ProtoMessage()               {}
func (*RoomOver) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{10} }

func (m *RoomOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomOver) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *RoomOver) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *RoomOver) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *RoomOver) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// 结算数据,百人场时为5个位置1庄家，2天，3地，4玄，5黄
type FreeRoomOver struct {
	Seat  uint32       `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Cards []uint32     `protobuf:"varint,2,rep,packed,name=cards" json:"cards,omitempty"`
	Value uint32       `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	Total int32        `protobuf:"varint,4,opt,name=total,proto3" json:"total,omitempty"`
	Score int32        `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
	List  []*RoomScore `protobuf:"bytes,6,rep,name=list" json:"list,omitempty"`
}

func (m *FreeRoomOver) Reset()                    { *m = FreeRoomOver{} }
func (*FreeRoomOver) ProtoMessage()               {}
func (*FreeRoomOver) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{11} }

func (m *FreeRoomOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *FreeRoomOver) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *FreeRoomOver) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *FreeRoomOver) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *FreeRoomOver) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *FreeRoomOver) GetList() []*RoomScore {
	if m != nil {
		return m.List
	}
	return nil
}

// 投票信息
type RoomScore struct {
	Seat   uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Userid string `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty"`
	Score  int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	Pond   uint32 `protobuf:"varint,4,opt,name=pond,proto3" json:"pond,omitempty"`
	Coin   uint32 `protobuf:"varint,5,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *RoomScore) Reset()                    { *m = RoomScore{} }
func (*RoomScore) ProtoMessage()               {}
func (*RoomScore) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{12} }

func (m *RoomScore) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomScore) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RoomScore) GetPond() uint32 {
	if m != nil {
		return m.Pond
	}
	return 0
}

func (m *RoomScore) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

//
type ClassicOver struct {
	Seat   uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Userid string   `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty"`
	Cards  []uint32 `protobuf:"varint,3,rep,packed,name=cards" json:"cards,omitempty"`
	Value  uint32   `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
	Bets   uint32   `protobuf:"varint,5,opt,name=bets,proto3" json:"bets,omitempty"`
	Score  int32    `protobuf:"varint,6,opt,name=score,proto3" json:"score,omitempty"`
	Coin   uint32   `protobuf:"varint,7,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *ClassicOver) Reset()                    { *m = ClassicOver{} }
func (*ClassicOver) ProtoMessage()               {}
func (*ClassicOver) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{13} }

func (m *ClassicOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *ClassicOver) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *ClassicOver) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *ClassicOver) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *ClassicOver) GetBets() uint32 {
	if m != nil {
		return m.Bets
	}
	return 0
}

func (m *ClassicOver) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ClassicOver) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

// 结算数据
type OverList struct {
	Seat     uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Userid   string   `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty"`
	Cards    []uint32 `protobuf:"varint,3,rep,packed,name=cards" json:"cards,omitempty"`
	Value    uint32   `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
	Round    uint32   `protobuf:"varint,5,opt,name=round,proto3" json:"round,omitempty"`
	Score    int32    `protobuf:"varint,6,opt,name=score,proto3" json:"score,omitempty"`
	Dealer   uint32   `protobuf:"varint,7,opt,name=dealer,proto3" json:"dealer,omitempty"`
	Bets     uint32   `protobuf:"varint,8,opt,name=bets,proto3" json:"bets,omitempty"`
	Nickname string   `protobuf:"bytes,9,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Photo    string   `protobuf:"bytes,10,opt,name=photo,proto3" json:"photo,omitempty"`
}

func (m *OverList) Reset()                    { *m = OverList{} }
func (*OverList) ProtoMessage()               {}
func (*OverList) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{14} }

func (m *OverList) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *OverList) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *OverList) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *OverList) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *OverList) GetRound() uint32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *OverList) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *OverList) GetDealer() uint32 {
	if m != nil {
		return m.Dealer
	}
	return 0
}

func (m *OverList) GetBets() uint32 {
	if m != nil {
		return m.Bets
	}
	return 0
}

func (m *OverList) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *OverList) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

// 投票信息
type RoomVote struct {
	Seat     uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Agree    []uint32 `protobuf:"varint,2,rep,packed,name=agree" json:"agree,omitempty"`
	Disagree []uint32 `protobuf:"varint,3,rep,packed,name=disagree" json:"disagree,omitempty"`
}

func (m *RoomVote) Reset()                    { *m = RoomVote{} }
func (*RoomVote) ProtoMessage()               {}
func (*RoomVote) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{15} }

func (m *RoomVote) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomVote) GetAgree() []uint32 {
	if m != nil {
		return m.Agree
	}
	return nil
}

func (m *RoomVote) GetDisagree() []uint32 {
	if m != nil {
		return m.Disagree
	}
	return nil
}

// 获取玩家的私人房间记录
type RecordList struct {
	Roomid     string      `protobuf:"bytes,1,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Rtype      uint32      `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Rname      string      `protobuf:"bytes,3,opt,name=rname,proto3" json:"rname,omitempty"`
	Count      uint32      `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Ante       uint32      `protobuf:"varint,5,opt,name=ante,proto3" json:"ante,omitempty"`
	Chat       uint32      `protobuf:"varint,6,opt,name=chat,proto3" json:"chat,omitempty"`
	Invitecode string      `protobuf:"bytes,7,opt,name=invitecode,proto3" json:"invitecode,omitempty"`
	TotalRound uint32      `protobuf:"varint,8,opt,name=totalRound,proto3" json:"totalRound,omitempty"`
	Userid     string      `protobuf:"bytes,9,opt,name=userid,proto3" json:"userid,omitempty"`
	Ctime      uint32      `protobuf:"varint,10,opt,name=ctime,proto3" json:"ctime,omitempty"`
	List       []*OverList `protobuf:"bytes,11,rep,name=list" json:"list,omitempty"`
}

func (m *RecordList) Reset()                    { *m = RecordList{} }
func (*RecordList) ProtoMessage()               {}
func (*RecordList) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{16} }

func (m *RecordList) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *RecordList) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *RecordList) GetRname() string {
	if m != nil {
		return m.Rname
	}
	return ""
}

func (m *RecordList) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *RecordList) GetAnte() uint32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *RecordList) GetChat() uint32 {
	if m != nil {
		return m.Chat
	}
	return 0
}

func (m *RecordList) GetInvitecode() string {
	if m != nil {
		return m.Invitecode
	}
	return ""
}

func (m *RecordList) GetTotalRound() uint32 {
	if m != nil {
		return m.TotalRound
	}
	return 0
}

func (m *RecordList) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RecordList) GetCtime() uint32 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *RecordList) GetList() []*OverList {
	if m != nil {
		return m.List
	}
	return nil
}

// 上庄列表
type DealerList struct {
	Userid   string `protobuf:"bytes,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname string `protobuf:"bytes,2,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Photo    string `protobuf:"bytes,3,opt,name=photo,proto3" json:"photo,omitempty"`
	Coin     uint32 `protobuf:"varint,4,opt,name=coin,proto3" json:"coin,omitempty"`
}

func (m *DealerList) Reset()                    { *m = DealerList{} }
func (*DealerList) ProtoMessage()               {}
func (*DealerList) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{17} }

func (m *DealerList) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *DealerList) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *DealerList) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *DealerList) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type FreeTrendList struct {
	Round uint32       `protobuf:"varint,1,opt,name=round,proto3" json:"round,omitempty"`
	List  []*FreeTrend `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
}

func (m *FreeTrendList) Reset()                    { *m = FreeTrendList{} }
func (*FreeTrendList) ProtoMessage()               {}
func (*FreeTrendList) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{18} }

func (m *FreeTrendList) GetRound() uint32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *FreeTrendList) GetList() []*FreeTrend {
	if m != nil {
		return m.List
	}
	return nil
}

type FreeTrend struct {
	Seat uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Win  bool   `protobuf:"varint,2,opt,name=win,proto3" json:"win,omitempty"`
}

func (m *FreeTrend) Reset()                    { *m = FreeTrend{} }
func (*FreeTrend) ProtoMessage()               {}
func (*FreeTrend) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{19} }

func (m *FreeTrend) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *FreeTrend) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

type PrizeCard struct {
	Card   uint32 `protobuf:"varint,1,opt,name=card,proto3" json:"card,omitempty"`
	Rtype  uint32 `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Number uint32 `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *PrizeCard) Reset()                    { *m = PrizeCard{} }
func (*PrizeCard) ProtoMessage()               {}
func (*PrizeCard) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{20} }

func (m *PrizeCard) GetCard() uint32 {
	if m != nil {
		return m.Card
	}
	return 0
}

func (m *PrizeCard) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *PrizeCard) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 牌面
type RoomCard struct {
	Seat      uint32   `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Handcards []uint32 `protobuf:"varint,2,rep,packed,name=handcards" json:"handcards,omitempty"`
	Kancards  []uint32 `protobuf:"varint,3,rep,packed,name=kancards" json:"kancards,omitempty"`
	Outcards  []uint32 `protobuf:"varint,4,rep,packed,name=outcards" json:"outcards,omitempty"`
	Chowcards []uint32 `protobuf:"varint,5,rep,packed,name=chowcards" json:"chowcards,omitempty"`
	Pongcards []uint32 `protobuf:"varint,6,rep,packed,name=pongcards" json:"pongcards,omitempty"`
	Ticards   []uint32 `protobuf:"varint,7,rep,packed,name=ticards" json:"ticards,omitempty"`
}

func (m *RoomCard) Reset()                    { *m = RoomCard{} }
func (*RoomCard) ProtoMessage()               {}
func (*RoomCard) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{21} }

func (m *RoomCard) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomCard) GetHandcards() []uint32 {
	if m != nil {
		return m.Handcards
	}
	return nil
}

func (m *RoomCard) GetKancards() []uint32 {
	if m != nil {
		return m.Kancards
	}
	return nil
}

func (m *RoomCard) GetOutcards() []uint32 {
	if m != nil {
		return m.Outcards
	}
	return nil
}

func (m *RoomCard) GetChowcards() []uint32 {
	if m != nil {
		return m.Chowcards
	}
	return nil
}

func (m *RoomCard) GetPongcards() []uint32 {
	if m != nil {
		return m.Pongcards
	}
	return nil
}

func (m *RoomCard) GetTicards() []uint32 {
	if m != nil {
		return m.Ticards
	}
	return nil
}

// 房间内位置数据
type RoomSeat struct {
	Seat     uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Userid   string `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty"`
	Nickname string `protobuf:"bytes,3,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Photo    string `protobuf:"bytes,4,opt,name=photo,proto3" json:"photo,omitempty"`
	Score    int32  `protobuf:"varint,5,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *RoomSeat) Reset()                    { *m = RoomSeat{} }
func (*RoomSeat) ProtoMessage()               {}
func (*RoomSeat) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{22} }

func (m *RoomSeat) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RoomSeat) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *RoomSeat) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *RoomSeat) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *RoomSeat) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// 单局结算数据
type ZiRoomOver struct {
	Seat   uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Total  int32  `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	Score  int32  `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	Coin   uint32 `protobuf:"varint,4,opt,name=coin,proto3" json:"coin,omitempty"`
	Points int32  `protobuf:"varint,5,opt,name=points,proto3" json:"points,omitempty"`
}

func (m *ZiRoomOver) Reset()                    { *m = ZiRoomOver{} }
func (*ZiRoomOver) ProtoMessage()               {}
func (*ZiRoomOver) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{23} }

func (m *ZiRoomOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *ZiRoomOver) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ZiRoomOver) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ZiRoomOver) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *ZiRoomOver) GetPoints() int32 {
	if m != nil {
		return m.Points
	}
	return 0
}

// 排位赛更新
type DanOver struct {
	Seat   uint32     `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Userid string     `protobuf:"bytes,2,opt,name=userid,proto3" json:"userid,omitempty"`
	Combat *DanCombat `protobuf:"bytes,3,opt,name=combat" json:"combat,omitempty"`
}

func (m *DanOver) Reset()                    { *m = DanOver{} }
func (*DanOver) ProtoMessage()               {}
func (*DanOver) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{24} }

func (m *DanOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *DanOver) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *DanOver) GetCombat() *DanCombat {
	if m != nil {
		return m.Combat
	}
	return nil
}

// 单局结算数据
type ZiRoomRound struct {
	Seat  uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Score int32  `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
	Round uint32 `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
}

func (m *ZiRoomRound) Reset()                    { *m = ZiRoomRound{} }
func (*ZiRoomRound) ProtoMessage()               {}
func (*ZiRoomRound) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{25} }

func (m *ZiRoomRound) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *ZiRoomRound) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ZiRoomRound) GetRound() uint32 {
	if m != nil {
		return m.Round
	}
	return 0
}

// 获取玩家的私人房间记录
type ZiRecordList struct {
	Info  *ZiRoomInfo    `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
	Seats []*RoomSeat    `protobuf:"bytes,2,rep,name=seats" json:"seats,omitempty"`
	List  []*ZiRoomRound `protobuf:"bytes,3,rep,name=list" json:"list,omitempty"`
}

func (m *ZiRecordList) Reset()                    { *m = ZiRecordList{} }
func (*ZiRecordList) ProtoMessage()               {}
func (*ZiRecordList) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{26} }

func (m *ZiRecordList) GetInfo() *ZiRoomInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *ZiRecordList) GetSeats() []*RoomSeat {
	if m != nil {
		return m.Seats
	}
	return nil
}

func (m *ZiRecordList) GetList() []*ZiRoomRound {
	if m != nil {
		return m.List
	}
	return nil
}

// 房间基本信息
type ZiRoomInfo struct {
	Roomid     string `protobuf:"bytes,1,opt,name=roomid,proto3" json:"roomid,omitempty"`
	Rtype      uint32 `protobuf:"varint,2,opt,name=rtype,proto3" json:"rtype,omitempty"`
	Rname      string `protobuf:"bytes,3,opt,name=rname,proto3" json:"rname,omitempty"`
	Expire     uint32 `protobuf:"varint,4,opt,name=expire,proto3" json:"expire,omitempty"`
	Count      uint32 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
	Invitecode string `protobuf:"bytes,6,opt,name=invitecode,proto3" json:"invitecode,omitempty"`
	Userid     string `protobuf:"bytes,7,opt,name=userid,proto3" json:"userid,omitempty"`
	Round      uint32 `protobuf:"varint,8,opt,name=round,proto3" json:"round,omitempty"`
	Ante       uint32 `protobuf:"varint,9,opt,name=ante,proto3" json:"ante,omitempty"`
	Chat       uint32 `protobuf:"varint,10,opt,name=chat,proto3" json:"chat,omitempty"`
	Dealer     uint32 `protobuf:"varint,11,opt,name=dealer,proto3" json:"dealer,omitempty"`
	Ctime      uint32 `protobuf:"varint,12,opt,name=ctime,proto3" json:"ctime,omitempty"`
	Xi         uint32 `protobuf:"varint,13,opt,name=xi,proto3" json:"xi,omitempty"`
}

func (m *ZiRoomInfo) Reset()                    { *m = ZiRoomInfo{} }
func (*ZiRoomInfo) ProtoMessage()               {}
func (*ZiRoomInfo) Descriptor() ([]byte, []int) { return fileDescriptorVo, []int{27} }

func (m *ZiRoomInfo) GetRoomid() string {
	if m != nil {
		return m.Roomid
	}
	return ""
}

func (m *ZiRoomInfo) GetRtype() uint32 {
	if m != nil {
		return m.Rtype
	}
	return 0
}

func (m *ZiRoomInfo) GetRname() string {
	if m != nil {
		return m.Rname
	}
	return ""
}

func (m *ZiRoomInfo) GetExpire() uint32 {
	if m != nil {
		return m.Expire
	}
	return 0
}

func (m *ZiRoomInfo) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ZiRoomInfo) GetInvitecode() string {
	if m != nil {
		return m.Invitecode
	}
	return ""
}

func (m *ZiRoomInfo) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *ZiRoomInfo) GetRound() uint32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *ZiRoomInfo) GetAnte() uint32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *ZiRoomInfo) GetChat() uint32 {
	if m != nil {
		return m.Chat
	}
	return 0
}

func (m *ZiRoomInfo) GetDealer() uint32 {
	if m != nil {
		return m.Dealer
	}
	return 0
}

func (m *ZiRoomInfo) GetCtime() uint32 {
	if m != nil {
		return m.Ctime
	}
	return 0
}

func (m *ZiRoomInfo) GetXi() uint32 {
	if m != nil {
		return m.Xi
	}
	return 0
}

func init() {
	proto.RegisterType((*UserData)(nil), "pb.UserData")
	proto.RegisterType((*UserInfo)(nil), "pb.UserInfo")
	proto.RegisterType((*RoomInfo)(nil), "pb.RoomInfo")
	proto.RegisterType((*Activity)(nil), "pb.Activity")
	proto.RegisterType((*VipInfo)(nil), "pb.VipInfo")
	proto.RegisterType((*RoomUser)(nil), "pb.RoomUser")
	proto.RegisterType((*RoomData)(nil), "pb.RoomData")
	proto.RegisterType((*RoomBets)(nil), "pb.RoomBets")
	proto.RegisterType((*FreeUser)(nil), "pb.FreeUser")
	proto.RegisterType((*FreeRoom)(nil), "pb.FreeRoom")
	proto.RegisterType((*RoomOver)(nil), "pb.RoomOver")
	proto.RegisterType((*FreeRoomOver)(nil), "pb.FreeRoomOver")
	proto.RegisterType((*RoomScore)(nil), "pb.RoomScore")
	proto.RegisterType((*ClassicOver)(nil), "pb.ClassicOver")
	proto.RegisterType((*OverList)(nil), "pb.OverList")
	proto.RegisterType((*RoomVote)(nil), "pb.RoomVote")
	proto.RegisterType((*RecordList)(nil), "pb.RecordList")
	proto.RegisterType((*DealerList)(nil), "pb.DealerList")
	proto.RegisterType((*FreeTrendList)(nil), "pb.FreeTrendList")
	proto.RegisterType((*FreeTrend)(nil), "pb.FreeTrend")
	proto.RegisterType((*PrizeCard)(nil), "pb.PrizeCard")
	proto.RegisterType((*RoomCard)(nil), "pb.RoomCard")
	proto.RegisterType((*RoomSeat)(nil), "pb.RoomSeat")
	proto.RegisterType((*ZiRoomOver)(nil), "pb.ZiRoomOver")
	proto.RegisterType((*DanOver)(nil), "pb.DanOver")
	proto.RegisterType((*ZiRoomRound)(nil), "pb.ZiRoomRound")
	proto.RegisterType((*ZiRecordList)(nil), "pb.ZiRecordList")
	proto.RegisterType((*ZiRoomInfo)(nil), "pb.ZiRoomInfo")
}
func (this *UserData) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UserData)
	if !ok {
		that2, ok := that.(UserData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	if this.Roomtype != that1.Roomtype {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Invitecode != that1.Invitecode {
		return false
	}
	if this.Agent != that1.Agent {
		return false
	}
	if this.Give != that1.Give {
		return false
	}
	if this.Bank != that1.Bank {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if !this.Vip.Equal(that1.Vip) {
		return false
	}
	return true
}
func (this *UserInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UserInfo)
	if !ok {
		that2, ok := that.(UserInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	return true
}
func (this *RoomInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomInfo)
	if !ok {
		that2, ok := that.(RoomInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Rname != that1.Rname {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Ante != that1.Ante {
		return false
	}
	if this.Chat != that1.Chat {
		return false
	}
	return true
}
func (this *Activity) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Activity)
	if !ok {
		that2, ok := that.(Activity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Firstpay != that1.Firstpay {
		return false
	}
	if this.Relieve != that1.Relieve {
		return false
	}
	if this.Bankrupt != that1.Bankrupt {
		return false
	}
	if this.Prizedraw != that1.Prizedraw {
		return false
	}
	if this.Leftdraw != that1.Leftdraw {
		return false
	}
	if this.Kicktimes != that1.Kicktimes {
		return false
	}
	return true
}
func (this *VipInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VipInfo)
	if !ok {
		that2, ok := that.(VipInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *RoomUser) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomUser)
	if !ok {
		that2, ok := that.(RoomUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Ready != that1.Ready {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Dealer != that1.Dealer {
		return false
	}
	if this.Bet != that1.Bet {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Num != that1.Num {
		return false
	}
	if this.Niu != that1.Niu {
		return false
	}
	if !this.Vip.Equal(that1.Vip) {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.Dan.Equal(that1.Dan) {
		return false
	}
	return true
}
func (this *RoomData) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomData)
	if !ok {
		that2, ok := that.(RoomData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Rname != that1.Rname {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Ante != that1.Ante {
		return false
	}
	if this.Chat != that1.Chat {
		return false
	}
	if this.Expire != that1.Expire {
		return false
	}
	if this.Invitecode != that1.Invitecode {
		return false
	}
	if this.Dealer != that1.Dealer {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Card != that1.Card {
		return false
	}
	if this.Xi != that1.Xi {
		return false
	}
	if this.Draw != that1.Draw {
		return false
	}
	if this.Discard != that1.Discard {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if this.Players != that1.Players {
		return false
	}
	return true
}
func (this *RoomBets) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomBets)
	if !ok {
		that2, ok := that.(RoomBets)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Bets != that1.Bets {
		return false
	}
	return true
}
func (this *FreeUser) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FreeUser)
	if !ok {
		that2, ok := that.(FreeUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Ready != that1.Ready {
		return false
	}
	if this.Bet != that1.Bet {
		return false
	}
	if len(this.Bets) != len(that1.Bets) {
		return false
	}
	for i := range this.Bets {
		if !this.Bets[i].Equal(that1.Bets[i]) {
			return false
		}
	}
	if !this.Vip.Equal(that1.Vip) {
		return false
	}
	return true
}
func (this *FreeRoom) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FreeRoom)
	if !ok {
		that2, ok := that.(FreeRoom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Rname != that1.Rname {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Ante != that1.Ante {
		return false
	}
	if this.Chat != that1.Chat {
		return false
	}
	if this.Dealer != that1.Dealer {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Pond != that1.Pond {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Timer != that1.Timer {
		return false
	}
	if this.DealerNum != that1.DealerNum {
		return false
	}
	if this.LeftDealerNum != that1.LeftDealerNum {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	return true
}
func (this *RoomOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomOver)
	if !ok {
		that2, ok := that.(RoomOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	return true
}
func (this *FreeRoomOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FreeRoomOver)
	if !ok {
		that2, ok := that.(FreeRoomOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *RoomScore) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomScore)
	if !ok {
		that2, ok := that.(RoomScore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Pond != that1.Pond {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	return true
}
func (this *ClassicOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ClassicOver)
	if !ok {
		that2, ok := that.(ClassicOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Bets != that1.Bets {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	return true
}
func (this *OverList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*OverList)
	if !ok {
		that2, ok := that.(OverList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Dealer != that1.Dealer {
		return false
	}
	if this.Bets != that1.Bets {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	return true
}
func (this *RoomVote) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomVote)
	if !ok {
		that2, ok := that.(RoomVote)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if len(this.Agree) != len(that1.Agree) {
		return false
	}
	for i := range this.Agree {
		if this.Agree[i] != that1.Agree[i] {
			return false
		}
	}
	if len(this.Disagree) != len(that1.Disagree) {
		return false
	}
	for i := range this.Disagree {
		if this.Disagree[i] != that1.Disagree[i] {
			return false
		}
	}
	return true
}
func (this *RecordList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RecordList)
	if !ok {
		that2, ok := that.(RecordList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Rname != that1.Rname {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Ante != that1.Ante {
		return false
	}
	if this.Chat != that1.Chat {
		return false
	}
	if this.Invitecode != that1.Invitecode {
		return false
	}
	if this.TotalRound != that1.TotalRound {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Ctime != that1.Ctime {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *DealerList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DealerList)
	if !ok {
		that2, ok := that.(DealerList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	return true
}
func (this *FreeTrendList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FreeTrendList)
	if !ok {
		that2, ok := that.(FreeTrendList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *FreeTrend) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*FreeTrend)
	if !ok {
		that2, ok := that.(FreeTrend)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Win != that1.Win {
		return false
	}
	return true
}
func (this *PrizeCard) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PrizeCard)
	if !ok {
		that2, ok := that.(PrizeCard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Card != that1.Card {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *RoomCard) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomCard)
	if !ok {
		that2, ok := that.(RoomCard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if len(this.Handcards) != len(that1.Handcards) {
		return false
	}
	for i := range this.Handcards {
		if this.Handcards[i] != that1.Handcards[i] {
			return false
		}
	}
	if len(this.Kancards) != len(that1.Kancards) {
		return false
	}
	for i := range this.Kancards {
		if this.Kancards[i] != that1.Kancards[i] {
			return false
		}
	}
	if len(this.Outcards) != len(that1.Outcards) {
		return false
	}
	for i := range this.Outcards {
		if this.Outcards[i] != that1.Outcards[i] {
			return false
		}
	}
	if len(this.Chowcards) != len(that1.Chowcards) {
		return false
	}
	for i := range this.Chowcards {
		if this.Chowcards[i] != that1.Chowcards[i] {
			return false
		}
	}
	if len(this.Pongcards) != len(that1.Pongcards) {
		return false
	}
	for i := range this.Pongcards {
		if this.Pongcards[i] != that1.Pongcards[i] {
			return false
		}
	}
	if len(this.Ticards) != len(that1.Ticards) {
		return false
	}
	for i := range this.Ticards {
		if this.Ticards[i] != that1.Ticards[i] {
			return false
		}
	}
	return true
}
func (this *RoomSeat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RoomSeat)
	if !ok {
		that2, ok := that.(RoomSeat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Nickname != that1.Nickname {
		return false
	}
	if this.Photo != that1.Photo {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	return true
}
func (this *ZiRoomOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZiRoomOver)
	if !ok {
		that2, ok := that.(ZiRoomOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Points != that1.Points {
		return false
	}
	return true
}
func (this *DanOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DanOver)
	if !ok {
		that2, ok := that.(DanOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if !this.Combat.Equal(that1.Combat) {
		return false
	}
	return true
}
func (this *ZiRoomRound) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZiRoomRound)
	if !ok {
		that2, ok := that.(ZiRoomRound)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	return true
}
func (this *ZiRecordList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZiRecordList)
	if !ok {
		that2, ok := that.(ZiRecordList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	if len(this.Seats) != len(that1.Seats) {
		return false
	}
	for i := range this.Seats {
		if !this.Seats[i].Equal(that1.Seats[i]) {
			return false
		}
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *ZiRoomInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ZiRoomInfo)
	if !ok {
		that2, ok := that.(ZiRoomInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Roomid != that1.Roomid {
		return false
	}
	if this.Rtype != that1.Rtype {
		return false
	}
	if this.Rname != that1.Rname {
		return false
	}
	if this.Expire != that1.Expire {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Invitecode != that1.Invitecode {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Round != that1.Round {
		return false
	}
	if this.Ante != that1.Ante {
		return false
	}
	if this.Chat != that1.Chat {
		return false
	}
	if this.Dealer != that1.Dealer {
		return false
	}
	if this.Ctime != that1.Ctime {
		return false
	}
	if this.Xi != that1.Xi {
		return false
	}
	return true
}
func (this *UserData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&pb.UserData{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "Sex: "+fmt.Sprintf("%#v", this.Sex)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "Roomtype: "+fmt.Sprintf("%#v", this.Roomtype)+",\n")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Invitecode: "+fmt.Sprintf("%#v", this.Invitecode)+",\n")
	s = append(s, "Agent: "+fmt.Sprintf("%#v", this.Agent)+",\n")
	s = append(s, "Give: "+fmt.Sprintf("%#v", this.Give)+",\n")
	s = append(s, "Bank: "+fmt.Sprintf("%#v", this.Bank)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	if this.Vip != nil {
		s = append(s, "Vip: "+fmt.Sprintf("%#v", this.Vip)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.UserInfo{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "Sex: "+fmt.Sprintf("%#v", this.Sex)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pb.RoomInfo{")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Rname: "+fmt.Sprintf("%#v", this.Rname)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Ante: "+fmt.Sprintf("%#v", this.Ante)+",\n")
	s = append(s, "Chat: "+fmt.Sprintf("%#v", this.Chat)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Activity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pb.Activity{")
	s = append(s, "Firstpay: "+fmt.Sprintf("%#v", this.Firstpay)+",\n")
	s = append(s, "Relieve: "+fmt.Sprintf("%#v", this.Relieve)+",\n")
	s = append(s, "Bankrupt: "+fmt.Sprintf("%#v", this.Bankrupt)+",\n")
	s = append(s, "Prizedraw: "+fmt.Sprintf("%#v", this.Prizedraw)+",\n")
	s = append(s, "Leftdraw: "+fmt.Sprintf("%#v", this.Leftdraw)+",\n")
	s = append(s, "Kicktimes: "+fmt.Sprintf("%#v", this.Kicktimes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VipInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.VipInfo{")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&pb.RoomUser{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "Sex: "+fmt.Sprintf("%#v", this.Sex)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Ready: "+fmt.Sprintf("%#v", this.Ready)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Dealer: "+fmt.Sprintf("%#v", this.Dealer)+",\n")
	s = append(s, "Bet: "+fmt.Sprintf("%#v", this.Bet)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",\n")
	s = append(s, "Niu: "+fmt.Sprintf("%#v", this.Niu)+",\n")
	if this.Vip != nil {
		s = append(s, "Vip: "+fmt.Sprintf("%#v", this.Vip)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.Dan != nil {
		s = append(s, "Dan: "+fmt.Sprintf("%#v", this.Dan)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 24)
	s = append(s, "&pb.RoomData{")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Rname: "+fmt.Sprintf("%#v", this.Rname)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Ante: "+fmt.Sprintf("%#v", this.Ante)+",\n")
	s = append(s, "Chat: "+fmt.Sprintf("%#v", this.Chat)+",\n")
	s = append(s, "Expire: "+fmt.Sprintf("%#v", this.Expire)+",\n")
	s = append(s, "Invitecode: "+fmt.Sprintf("%#v", this.Invitecode)+",\n")
	s = append(s, "Dealer: "+fmt.Sprintf("%#v", this.Dealer)+",\n")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Card: "+fmt.Sprintf("%#v", this.Card)+",\n")
	s = append(s, "Xi: "+fmt.Sprintf("%#v", this.Xi)+",\n")
	s = append(s, "Draw: "+fmt.Sprintf("%#v", this.Draw)+",\n")
	s = append(s, "Discard: "+fmt.Sprintf("%#v", this.Discard)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	s = append(s, "Players: "+fmt.Sprintf("%#v", this.Players)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomBets) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.RoomBets{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Bets: "+fmt.Sprintf("%#v", this.Bets)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FreeUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&pb.FreeUser{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "Sex: "+fmt.Sprintf("%#v", this.Sex)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Ready: "+fmt.Sprintf("%#v", this.Ready)+",\n")
	s = append(s, "Bet: "+fmt.Sprintf("%#v", this.Bet)+",\n")
	if this.Bets != nil {
		s = append(s, "Bets: "+fmt.Sprintf("%#v", this.Bets)+",\n")
	}
	if this.Vip != nil {
		s = append(s, "Vip: "+fmt.Sprintf("%#v", this.Vip)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FreeRoom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 19)
	s = append(s, "&pb.FreeRoom{")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Rname: "+fmt.Sprintf("%#v", this.Rname)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Ante: "+fmt.Sprintf("%#v", this.Ante)+",\n")
	s = append(s, "Chat: "+fmt.Sprintf("%#v", this.Chat)+",\n")
	s = append(s, "Dealer: "+fmt.Sprintf("%#v", this.Dealer)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Pond: "+fmt.Sprintf("%#v", this.Pond)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Timer: "+fmt.Sprintf("%#v", this.Timer)+",\n")
	s = append(s, "DealerNum: "+fmt.Sprintf("%#v", this.DealerNum)+",\n")
	s = append(s, "LeftDealerNum: "+fmt.Sprintf("%#v", this.LeftDealerNum)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.RoomOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FreeRoomOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pb.FreeRoomOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomScore) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.RoomScore{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Pond: "+fmt.Sprintf("%#v", this.Pond)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClassicOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.ClassicOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Bets: "+fmt.Sprintf("%#v", this.Bets)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OverList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&pb.OverList{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Dealer: "+fmt.Sprintf("%#v", this.Dealer)+",\n")
	s = append(s, "Bets: "+fmt.Sprintf("%#v", this.Bets)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomVote) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.RoomVote{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Agree: "+fmt.Sprintf("%#v", this.Agree)+",\n")
	s = append(s, "Disagree: "+fmt.Sprintf("%#v", this.Disagree)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecordList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&pb.RecordList{")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Rname: "+fmt.Sprintf("%#v", this.Rname)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Ante: "+fmt.Sprintf("%#v", this.Ante)+",\n")
	s = append(s, "Chat: "+fmt.Sprintf("%#v", this.Chat)+",\n")
	s = append(s, "Invitecode: "+fmt.Sprintf("%#v", this.Invitecode)+",\n")
	s = append(s, "TotalRound: "+fmt.Sprintf("%#v", this.TotalRound)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Ctime: "+fmt.Sprintf("%#v", this.Ctime)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DealerList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.DealerList{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FreeTrendList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.FreeTrendList{")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FreeTrend) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.FreeTrend{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Win: "+fmt.Sprintf("%#v", this.Win)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PrizeCard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.PrizeCard{")
	s = append(s, "Card: "+fmt.Sprintf("%#v", this.Card)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomCard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.RoomCard{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Handcards: "+fmt.Sprintf("%#v", this.Handcards)+",\n")
	s = append(s, "Kancards: "+fmt.Sprintf("%#v", this.Kancards)+",\n")
	s = append(s, "Outcards: "+fmt.Sprintf("%#v", this.Outcards)+",\n")
	s = append(s, "Chowcards: "+fmt.Sprintf("%#v", this.Chowcards)+",\n")
	s = append(s, "Pongcards: "+fmt.Sprintf("%#v", this.Pongcards)+",\n")
	s = append(s, "Ticards: "+fmt.Sprintf("%#v", this.Ticards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomSeat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.RoomSeat{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Nickname: "+fmt.Sprintf("%#v", this.Nickname)+",\n")
	s = append(s, "Photo: "+fmt.Sprintf("%#v", this.Photo)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZiRoomOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.ZiRoomOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Total: "+fmt.Sprintf("%#v", this.Total)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Points: "+fmt.Sprintf("%#v", this.Points)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DanOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.DanOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	if this.Combat != nil {
		s = append(s, "Combat: "+fmt.Sprintf("%#v", this.Combat)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZiRoomRound) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.ZiRoomRound{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Score: "+fmt.Sprintf("%#v", this.Score)+",\n")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZiRecordList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.ZiRecordList{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Seats != nil {
		s = append(s, "Seats: "+fmt.Sprintf("%#v", this.Seats)+",\n")
	}
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ZiRoomInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&pb.ZiRoomInfo{")
	s = append(s, "Roomid: "+fmt.Sprintf("%#v", this.Roomid)+",\n")
	s = append(s, "Rtype: "+fmt.Sprintf("%#v", this.Rtype)+",\n")
	s = append(s, "Rname: "+fmt.Sprintf("%#v", this.Rname)+",\n")
	s = append(s, "Expire: "+fmt.Sprintf("%#v", this.Expire)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Invitecode: "+fmt.Sprintf("%#v", this.Invitecode)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Round: "+fmt.Sprintf("%#v", this.Round)+",\n")
	s = append(s, "Ante: "+fmt.Sprintf("%#v", this.Ante)+",\n")
	s = append(s, "Chat: "+fmt.Sprintf("%#v", this.Chat)+",\n")
	s = append(s, "Dealer: "+fmt.Sprintf("%#v", this.Dealer)+",\n")
	s = append(s, "Ctime: "+fmt.Sprintf("%#v", this.Ctime)+",\n")
	s = append(s, "Xi: "+fmt.Sprintf("%#v", this.Xi)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringVo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UserData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Sex))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Diamond))
	}
	if m.Roomtype != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Roomtype))
	}
	if len(m.Roomid) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if len(m.Invitecode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Invitecode)))
		i += copy(dAtA[i:], m.Invitecode)
	}
	if len(m.Agent) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Agent)))
		i += copy(dAtA[i:], m.Agent)
	}
	if m.Give != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Give))
	}
	if m.Bank != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bank))
	}
	if m.Data != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Data.Size()))
		n1, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Vip != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Vip.Size()))
		n2, err := m.Vip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *UserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Sex))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Diamond))
	}
	return i, nil
}

func (m *RoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if len(m.Rname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Rname)))
		i += copy(dAtA[i:], m.Rname)
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Count))
	}
	if m.Ante != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ante))
	}
	if m.Chat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Chat))
	}
	return i, nil
}

func (m *Activity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Activity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Firstpay != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Firstpay))
	}
	if m.Relieve != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Relieve))
	}
	if m.Bankrupt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bankrupt))
	}
	if m.Prizedraw != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Prizedraw))
	}
	if m.Leftdraw != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Leftdraw))
	}
	if m.Kicktimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Kicktimes))
	}
	return i, nil
}

func (m *VipInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Level))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *RoomUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Sex))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Diamond))
	}
	if m.Seat != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Ready {
		dAtA[i] = 0x48
		i++
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Score != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Dealer != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dealer))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bet))
	}
	if len(m.Cards) > 0 {
		dAtA4 := make([]byte, len(m.Cards)*10)
		var j3 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.Num != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Num))
	}
	if m.Niu {
		dAtA[i] = 0x78
		i++
		if m.Niu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Vip != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Vip.Size()))
		n5, err := m.Vip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Value != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Value))
	}
	if m.Dan != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dan.Size()))
		n6, err := m.Dan.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *RoomData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if len(m.Rname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Rname)))
		i += copy(dAtA[i:], m.Rname)
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Count))
	}
	if m.Ante != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ante))
	}
	if m.Chat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Chat))
	}
	if m.Expire != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Expire))
	}
	if len(m.Invitecode) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Invitecode)))
		i += copy(dAtA[i:], m.Invitecode)
	}
	if m.Dealer != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dealer))
	}
	if m.Round != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Round))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.State != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.State))
	}
	if m.Card != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Card))
	}
	if m.Xi != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Xi))
	}
	if m.Draw != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Draw))
	}
	if m.Discard != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Discard))
	}
	if m.Seat != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Number))
	}
	if m.Total != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Total))
	}
	if m.Players != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Players))
	}
	return i, nil
}

func (m *RoomBets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomBets) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Bets != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bets))
	}
	return i, nil
}

func (m *FreeUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Sex))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Diamond))
	}
	if m.Seat != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Ready {
		dAtA[i] = 0x48
		i++
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Bet != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bet))
	}
	if len(m.Bets) > 0 {
		for _, msg := range m.Bets {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintVo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Vip != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Vip.Size()))
		n7, err := m.Vip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *FreeRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeRoom) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if len(m.Rname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Rname)))
		i += copy(dAtA[i:], m.Rname)
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Count))
	}
	if m.Ante != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ante))
	}
	if m.Chat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Chat))
	}
	if m.Dealer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dealer))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Pond != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Pond))
	}
	if m.State != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.State))
	}
	if m.Timer != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Timer))
	}
	if m.DealerNum != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.DealerNum))
	}
	if m.LeftDealerNum != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.LeftDealerNum))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	return i, nil
}

func (m *RoomOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Cards) > 0 {
		dAtA9 := make([]byte, len(m.Cards)*10)
		var j8 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.Value != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Value))
	}
	if m.Total != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Total))
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *FreeRoomOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeRoomOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Cards) > 0 {
		dAtA11 := make([]byte, len(m.Cards)*10)
		var j10 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.Value != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Value))
	}
	if m.Total != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Total))
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x32
			i++
			i = encodeVarintVo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RoomScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Pond != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Pond))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ClassicOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassicOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Cards) > 0 {
		dAtA13 := make([]byte, len(m.Cards)*10)
		var j12 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if m.Value != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Value))
	}
	if m.Bets != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bets))
	}
	if m.Score != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *OverList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OverList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Cards) > 0 {
		dAtA15 := make([]byte, len(m.Cards)*10)
		var j14 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.Value != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Value))
	}
	if m.Round != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Round))
	}
	if m.Score != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Dealer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dealer))
	}
	if m.Bets != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Bets))
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	return i, nil
}

func (m *RoomVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomVote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Agree) > 0 {
		dAtA17 := make([]byte, len(m.Agree)*10)
		var j16 int
		for _, num := range m.Agree {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.Disagree) > 0 {
		dAtA19 := make([]byte, len(m.Disagree)*10)
		var j18 int
		for _, num := range m.Disagree {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	return i, nil
}

func (m *RecordList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if len(m.Rname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Rname)))
		i += copy(dAtA[i:], m.Rname)
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Count))
	}
	if m.Ante != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ante))
	}
	if m.Chat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Chat))
	}
	if len(m.Invitecode) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Invitecode)))
		i += copy(dAtA[i:], m.Invitecode)
	}
	if m.TotalRound != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.TotalRound))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ctime))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintVo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DealerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DealerList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *FreeTrendList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeTrendList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Round))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FreeTrend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreeTrend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Win {
		dAtA[i] = 0x10
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PrizeCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrizeCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Card))
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *RoomCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Handcards) > 0 {
		dAtA21 := make([]byte, len(m.Handcards)*10)
		var j20 int
		for _, num := range m.Handcards {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if len(m.Kancards) > 0 {
		dAtA23 := make([]byte, len(m.Kancards)*10)
		var j22 int
		for _, num := range m.Kancards {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	if len(m.Outcards) > 0 {
		dAtA25 := make([]byte, len(m.Outcards)*10)
		var j24 int
		for _, num := range m.Outcards {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintVo(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	if len(m.Chowcards) > 0 {
		dAtA27 := make([]byte, len(m.Chowcards)*10)
		var j26 int
		for _, num := range m.Chowcards {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	if len(m.Pongcards) > 0 {
		dAtA29 := make([]byte, len(m.Pongcards)*10)
		var j28 int
		for _, num := range m.Pongcards {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintVo(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if len(m.Ticards) > 0 {
		dAtA31 := make([]byte, len(m.Ticards)*10)
		var j30 int
		for _, num := range m.Ticards {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVo(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	return i, nil
}

func (m *RoomSeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomSeat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Score != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ZiRoomOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZiRoomOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Total))
	}
	if m.Score != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Coin))
	}
	if m.Points != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Points))
	}
	return i, nil
}

func (m *DanOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DanOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Combat != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Combat.Size()))
		n32, err := m.Combat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *ZiRoomRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZiRoomRound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Seat))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Score))
	}
	if m.Round != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Round))
	}
	return i, nil
}

func (m *ZiRecordList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZiRecordList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Info.Size()))
		n33, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Seats) > 0 {
		for _, msg := range m.Seats {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintVo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ZiRoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZiRoomInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Roomid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Roomid)))
		i += copy(dAtA[i:], m.Roomid)
	}
	if m.Rtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Rtype))
	}
	if len(m.Rname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Rname)))
		i += copy(dAtA[i:], m.Rname)
	}
	if m.Expire != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Expire))
	}
	if m.Count != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Count))
	}
	if len(m.Invitecode) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Invitecode)))
		i += copy(dAtA[i:], m.Invitecode)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintVo(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Round != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Round))
	}
	if m.Ante != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ante))
	}
	if m.Chat != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Chat))
	}
	if m.Dealer != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Dealer))
	}
	if m.Ctime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Ctime))
	}
	if m.Xi != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintVo(dAtA, i, uint64(m.Xi))
	}
	return i, nil
}

func encodeFixed64Vo(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Vo(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintVo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovVo(uint64(m.Sex))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Diamond != 0 {
		n += 1 + sovVo(uint64(m.Diamond))
	}
	if m.Roomtype != 0 {
		n += 1 + sovVo(uint64(m.Roomtype))
	}
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Invitecode)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Agent)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Give != 0 {
		n += 1 + sovVo(uint64(m.Give))
	}
	if m.Bank != 0 {
		n += 1 + sovVo(uint64(m.Bank))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Vip != nil {
		l = m.Vip.Size()
		n += 1 + l + sovVo(uint64(l))
	}
	return n
}

func (m *UserInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovVo(uint64(m.Sex))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Diamond != 0 {
		n += 1 + sovVo(uint64(m.Diamond))
	}
	return n
}

func (m *RoomInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	l = len(m.Rname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovVo(uint64(m.Count))
	}
	if m.Ante != 0 {
		n += 1 + sovVo(uint64(m.Ante))
	}
	if m.Chat != 0 {
		n += 1 + sovVo(uint64(m.Chat))
	}
	return n
}

func (m *Activity) Size() (n int) {
	var l int
	_ = l
	if m.Firstpay != 0 {
		n += 1 + sovVo(uint64(m.Firstpay))
	}
	if m.Relieve != 0 {
		n += 1 + sovVo(uint64(m.Relieve))
	}
	if m.Bankrupt != 0 {
		n += 1 + sovVo(uint64(m.Bankrupt))
	}
	if m.Prizedraw != 0 {
		n += 1 + sovVo(uint64(m.Prizedraw))
	}
	if m.Leftdraw != 0 {
		n += 1 + sovVo(uint64(m.Leftdraw))
	}
	if m.Kicktimes != 0 {
		n += 1 + sovVo(uint64(m.Kicktimes))
	}
	return n
}

func (m *VipInfo) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovVo(uint64(m.Level))
	}
	if m.Number != 0 {
		n += 1 + sovVo(uint64(m.Number))
	}
	return n
}

func (m *RoomUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovVo(uint64(m.Sex))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Diamond != 0 {
		n += 1 + sovVo(uint64(m.Diamond))
	}
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Ready {
		n += 2
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Dealer != 0 {
		n += 1 + sovVo(uint64(m.Dealer))
	}
	if m.Bet != 0 {
		n += 1 + sovVo(uint64(m.Bet))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if m.Num != 0 {
		n += 1 + sovVo(uint64(m.Num))
	}
	if m.Niu {
		n += 2
	}
	if m.Vip != nil {
		l = m.Vip.Size()
		n += 2 + l + sovVo(uint64(l))
	}
	if m.Value != 0 {
		n += 2 + sovVo(uint64(m.Value))
	}
	if m.Dan != nil {
		l = m.Dan.Size()
		n += 2 + l + sovVo(uint64(l))
	}
	return n
}

func (m *RoomData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	l = len(m.Rname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovVo(uint64(m.Count))
	}
	if m.Ante != 0 {
		n += 1 + sovVo(uint64(m.Ante))
	}
	if m.Chat != 0 {
		n += 1 + sovVo(uint64(m.Chat))
	}
	if m.Expire != 0 {
		n += 1 + sovVo(uint64(m.Expire))
	}
	l = len(m.Invitecode)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Dealer != 0 {
		n += 1 + sovVo(uint64(m.Dealer))
	}
	if m.Round != 0 {
		n += 1 + sovVo(uint64(m.Round))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovVo(uint64(m.State))
	}
	if m.Card != 0 {
		n += 1 + sovVo(uint64(m.Card))
	}
	if m.Xi != 0 {
		n += 1 + sovVo(uint64(m.Xi))
	}
	if m.Draw != 0 {
		n += 1 + sovVo(uint64(m.Draw))
	}
	if m.Discard != 0 {
		n += 2 + sovVo(uint64(m.Discard))
	}
	if m.Seat != 0 {
		n += 2 + sovVo(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 2 + sovVo(uint64(m.Number))
	}
	if m.Total != 0 {
		n += 2 + sovVo(uint64(m.Total))
	}
	if m.Players != 0 {
		n += 2 + sovVo(uint64(m.Players))
	}
	return n
}

func (m *RoomBets) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Bets != 0 {
		n += 1 + sovVo(uint64(m.Bets))
	}
	return n
}

func (m *FreeUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovVo(uint64(m.Sex))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Diamond != 0 {
		n += 1 + sovVo(uint64(m.Diamond))
	}
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Ready {
		n += 2
	}
	if m.Bet != 0 {
		n += 1 + sovVo(uint64(m.Bet))
	}
	if len(m.Bets) > 0 {
		for _, e := range m.Bets {
			l = e.Size()
			n += 1 + l + sovVo(uint64(l))
		}
	}
	if m.Vip != nil {
		l = m.Vip.Size()
		n += 1 + l + sovVo(uint64(l))
	}
	return n
}

func (m *FreeRoom) Size() (n int) {
	var l int
	_ = l
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	l = len(m.Rname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovVo(uint64(m.Count))
	}
	if m.Ante != 0 {
		n += 1 + sovVo(uint64(m.Ante))
	}
	if m.Chat != 0 {
		n += 1 + sovVo(uint64(m.Chat))
	}
	if m.Dealer != 0 {
		n += 1 + sovVo(uint64(m.Dealer))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Pond != 0 {
		n += 1 + sovVo(uint64(m.Pond))
	}
	if m.State != 0 {
		n += 1 + sovVo(uint64(m.State))
	}
	if m.Timer != 0 {
		n += 1 + sovVo(uint64(m.Timer))
	}
	if m.DealerNum != 0 {
		n += 1 + sovVo(uint64(m.DealerNum))
	}
	if m.LeftDealerNum != 0 {
		n += 1 + sovVo(uint64(m.LeftDealerNum))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	return n
}

func (m *RoomOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if m.Value != 0 {
		n += 1 + sovVo(uint64(m.Value))
	}
	if m.Total != 0 {
		n += 1 + sovVo(uint64(m.Total))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	return n
}

func (m *FreeRoomOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if m.Value != 0 {
		n += 1 + sovVo(uint64(m.Value))
	}
	if m.Total != 0 {
		n += 1 + sovVo(uint64(m.Total))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovVo(uint64(l))
		}
	}
	return n
}

func (m *RoomScore) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Pond != 0 {
		n += 1 + sovVo(uint64(m.Pond))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	return n
}

func (m *ClassicOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if m.Value != 0 {
		n += 1 + sovVo(uint64(m.Value))
	}
	if m.Bets != 0 {
		n += 1 + sovVo(uint64(m.Bets))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	return n
}

func (m *OverList) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if m.Value != 0 {
		n += 1 + sovVo(uint64(m.Value))
	}
	if m.Round != 0 {
		n += 1 + sovVo(uint64(m.Round))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Dealer != 0 {
		n += 1 + sovVo(uint64(m.Dealer))
	}
	if m.Bets != 0 {
		n += 1 + sovVo(uint64(m.Bets))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	return n
}

func (m *RoomVote) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if len(m.Agree) > 0 {
		l = 0
		for _, e := range m.Agree {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Disagree) > 0 {
		l = 0
		for _, e := range m.Disagree {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	return n
}

func (m *RecordList) Size() (n int) {
	var l int
	_ = l
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	l = len(m.Rname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovVo(uint64(m.Count))
	}
	if m.Ante != 0 {
		n += 1 + sovVo(uint64(m.Ante))
	}
	if m.Chat != 0 {
		n += 1 + sovVo(uint64(m.Chat))
	}
	l = len(m.Invitecode)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.TotalRound != 0 {
		n += 1 + sovVo(uint64(m.TotalRound))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Ctime != 0 {
		n += 1 + sovVo(uint64(m.Ctime))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovVo(uint64(l))
		}
	}
	return n
}

func (m *DealerList) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	return n
}

func (m *FreeTrendList) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 1 + sovVo(uint64(m.Round))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovVo(uint64(l))
		}
	}
	return n
}

func (m *FreeTrend) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Win {
		n += 2
	}
	return n
}

func (m *PrizeCard) Size() (n int) {
	var l int
	_ = l
	if m.Card != 0 {
		n += 1 + sovVo(uint64(m.Card))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	if m.Number != 0 {
		n += 1 + sovVo(uint64(m.Number))
	}
	return n
}

func (m *RoomCard) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if len(m.Handcards) > 0 {
		l = 0
		for _, e := range m.Handcards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Kancards) > 0 {
		l = 0
		for _, e := range m.Kancards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Outcards) > 0 {
		l = 0
		for _, e := range m.Outcards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Chowcards) > 0 {
		l = 0
		for _, e := range m.Chowcards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Pongcards) > 0 {
		l = 0
		for _, e := range m.Pongcards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	if len(m.Ticards) > 0 {
		l = 0
		for _, e := range m.Ticards {
			l += sovVo(uint64(e))
		}
		n += 1 + sovVo(uint64(l)) + l
	}
	return n
}

func (m *RoomSeat) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	return n
}

func (m *ZiRoomOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Total != 0 {
		n += 1 + sovVo(uint64(m.Total))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Coin != 0 {
		n += 1 + sovVo(uint64(m.Coin))
	}
	if m.Points != 0 {
		n += 1 + sovVo(uint64(m.Points))
	}
	return n
}

func (m *DanOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Combat != nil {
		l = m.Combat.Size()
		n += 1 + l + sovVo(uint64(l))
	}
	return n
}

func (m *ZiRoomRound) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovVo(uint64(m.Seat))
	}
	if m.Score != 0 {
		n += 1 + sovVo(uint64(m.Score))
	}
	if m.Round != 0 {
		n += 1 + sovVo(uint64(m.Round))
	}
	return n
}

func (m *ZiRecordList) Size() (n int) {
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovVo(uint64(l))
	}
	if len(m.Seats) > 0 {
		for _, e := range m.Seats {
			l = e.Size()
			n += 1 + l + sovVo(uint64(l))
		}
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovVo(uint64(l))
		}
	}
	return n
}

func (m *ZiRoomInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Roomid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Rtype != 0 {
		n += 1 + sovVo(uint64(m.Rtype))
	}
	l = len(m.Rname)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Expire != 0 {
		n += 1 + sovVo(uint64(m.Expire))
	}
	if m.Count != 0 {
		n += 1 + sovVo(uint64(m.Count))
	}
	l = len(m.Invitecode)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovVo(uint64(l))
	}
	if m.Round != 0 {
		n += 1 + sovVo(uint64(m.Round))
	}
	if m.Ante != 0 {
		n += 1 + sovVo(uint64(m.Ante))
	}
	if m.Chat != 0 {
		n += 1 + sovVo(uint64(m.Chat))
	}
	if m.Dealer != 0 {
		n += 1 + sovVo(uint64(m.Dealer))
	}
	if m.Ctime != 0 {
		n += 1 + sovVo(uint64(m.Ctime))
	}
	if m.Xi != 0 {
		n += 1 + sovVo(uint64(m.Xi))
	}
	return n
}

func sovVo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVo(x uint64) (n int) {
	return sovVo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UserData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserData{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Phone:` + fmt.Sprintf("%v", this.Phone) + `,`,
		`Sex:` + fmt.Sprintf("%v", this.Sex) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`Roomtype:` + fmt.Sprintf("%v", this.Roomtype) + `,`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Invitecode:` + fmt.Sprintf("%v", this.Invitecode) + `,`,
		`Agent:` + fmt.Sprintf("%v", this.Agent) + `,`,
		`Give:` + fmt.Sprintf("%v", this.Give) + `,`,
		`Bank:` + fmt.Sprintf("%v", this.Bank) + `,`,
		`Data:` + strings.Replace(fmt.Sprintf("%v", this.Data), "Activity", "Activity", 1) + `,`,
		`Vip:` + strings.Replace(fmt.Sprintf("%v", this.Vip), "VipInfo", "VipInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserInfo{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Phone:` + fmt.Sprintf("%v", this.Phone) + `,`,
		`Sex:` + fmt.Sprintf("%v", this.Sex) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomInfo{`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Rname:` + fmt.Sprintf("%v", this.Rname) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Ante:` + fmt.Sprintf("%v", this.Ante) + `,`,
		`Chat:` + fmt.Sprintf("%v", this.Chat) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Activity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Activity{`,
		`Firstpay:` + fmt.Sprintf("%v", this.Firstpay) + `,`,
		`Relieve:` + fmt.Sprintf("%v", this.Relieve) + `,`,
		`Bankrupt:` + fmt.Sprintf("%v", this.Bankrupt) + `,`,
		`Prizedraw:` + fmt.Sprintf("%v", this.Prizedraw) + `,`,
		`Leftdraw:` + fmt.Sprintf("%v", this.Leftdraw) + `,`,
		`Kicktimes:` + fmt.Sprintf("%v", this.Kicktimes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VipInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VipInfo{`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomUser{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Phone:` + fmt.Sprintf("%v", this.Phone) + `,`,
		`Sex:` + fmt.Sprintf("%v", this.Sex) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Ready:` + fmt.Sprintf("%v", this.Ready) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Dealer:` + fmt.Sprintf("%v", this.Dealer) + `,`,
		`Bet:` + fmt.Sprintf("%v", this.Bet) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`Niu:` + fmt.Sprintf("%v", this.Niu) + `,`,
		`Vip:` + strings.Replace(fmt.Sprintf("%v", this.Vip), "VipInfo", "VipInfo", 1) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Dan:` + strings.Replace(fmt.Sprintf("%v", this.Dan), "DanCombat", "DanCombat", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomData{`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Rname:` + fmt.Sprintf("%v", this.Rname) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Ante:` + fmt.Sprintf("%v", this.Ante) + `,`,
		`Chat:` + fmt.Sprintf("%v", this.Chat) + `,`,
		`Expire:` + fmt.Sprintf("%v", this.Expire) + `,`,
		`Invitecode:` + fmt.Sprintf("%v", this.Invitecode) + `,`,
		`Dealer:` + fmt.Sprintf("%v", this.Dealer) + `,`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Card:` + fmt.Sprintf("%v", this.Card) + `,`,
		`Xi:` + fmt.Sprintf("%v", this.Xi) + `,`,
		`Draw:` + fmt.Sprintf("%v", this.Draw) + `,`,
		`Discard:` + fmt.Sprintf("%v", this.Discard) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Players:` + fmt.Sprintf("%v", this.Players) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomBets) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomBets{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Bets:` + fmt.Sprintf("%v", this.Bets) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreeUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreeUser{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Phone:` + fmt.Sprintf("%v", this.Phone) + `,`,
		`Sex:` + fmt.Sprintf("%v", this.Sex) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Ready:` + fmt.Sprintf("%v", this.Ready) + `,`,
		`Bet:` + fmt.Sprintf("%v", this.Bet) + `,`,
		`Bets:` + strings.Replace(fmt.Sprintf("%v", this.Bets), "RoomBets", "RoomBets", 1) + `,`,
		`Vip:` + strings.Replace(fmt.Sprintf("%v", this.Vip), "VipInfo", "VipInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreeRoom) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreeRoom{`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Rname:` + fmt.Sprintf("%v", this.Rname) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Ante:` + fmt.Sprintf("%v", this.Ante) + `,`,
		`Chat:` + fmt.Sprintf("%v", this.Chat) + `,`,
		`Dealer:` + fmt.Sprintf("%v", this.Dealer) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Pond:` + fmt.Sprintf("%v", this.Pond) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Timer:` + fmt.Sprintf("%v", this.Timer) + `,`,
		`DealerNum:` + fmt.Sprintf("%v", this.DealerNum) + `,`,
		`LeftDealerNum:` + fmt.Sprintf("%v", this.LeftDealerNum) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreeRoomOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreeRoomOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "RoomScore", "RoomScore", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomScore) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomScore{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Pond:` + fmt.Sprintf("%v", this.Pond) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClassicOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClassicOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Bets:` + fmt.Sprintf("%v", this.Bets) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OverList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OverList{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Dealer:` + fmt.Sprintf("%v", this.Dealer) + `,`,
		`Bets:` + fmt.Sprintf("%v", this.Bets) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomVote) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomVote{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Agree:` + fmt.Sprintf("%v", this.Agree) + `,`,
		`Disagree:` + fmt.Sprintf("%v", this.Disagree) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecordList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecordList{`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Rname:` + fmt.Sprintf("%v", this.Rname) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Ante:` + fmt.Sprintf("%v", this.Ante) + `,`,
		`Chat:` + fmt.Sprintf("%v", this.Chat) + `,`,
		`Invitecode:` + fmt.Sprintf("%v", this.Invitecode) + `,`,
		`TotalRound:` + fmt.Sprintf("%v", this.TotalRound) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Ctime:` + fmt.Sprintf("%v", this.Ctime) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "OverList", "OverList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DealerList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DealerList{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreeTrendList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreeTrendList{`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "FreeTrend", "FreeTrend", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FreeTrend) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FreeTrend{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Win:` + fmt.Sprintf("%v", this.Win) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrizeCard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrizeCard{`,
		`Card:` + fmt.Sprintf("%v", this.Card) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomCard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomCard{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Handcards:` + fmt.Sprintf("%v", this.Handcards) + `,`,
		`Kancards:` + fmt.Sprintf("%v", this.Kancards) + `,`,
		`Outcards:` + fmt.Sprintf("%v", this.Outcards) + `,`,
		`Chowcards:` + fmt.Sprintf("%v", this.Chowcards) + `,`,
		`Pongcards:` + fmt.Sprintf("%v", this.Pongcards) + `,`,
		`Ticards:` + fmt.Sprintf("%v", this.Ticards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomSeat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomSeat{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Nickname:` + fmt.Sprintf("%v", this.Nickname) + `,`,
		`Photo:` + fmt.Sprintf("%v", this.Photo) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ZiRoomOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ZiRoomOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Total:` + fmt.Sprintf("%v", this.Total) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Points:` + fmt.Sprintf("%v", this.Points) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DanOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DanOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Combat:` + strings.Replace(fmt.Sprintf("%v", this.Combat), "DanCombat", "DanCombat", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ZiRoomRound) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ZiRoomRound{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Score:` + fmt.Sprintf("%v", this.Score) + `,`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ZiRecordList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ZiRecordList{`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "ZiRoomInfo", "ZiRoomInfo", 1) + `,`,
		`Seats:` + strings.Replace(fmt.Sprintf("%v", this.Seats), "RoomSeat", "RoomSeat", 1) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "ZiRoomRound", "ZiRoomRound", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ZiRoomInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ZiRoomInfo{`,
		`Roomid:` + fmt.Sprintf("%v", this.Roomid) + `,`,
		`Rtype:` + fmt.Sprintf("%v", this.Rtype) + `,`,
		`Rname:` + fmt.Sprintf("%v", this.Rname) + `,`,
		`Expire:` + fmt.Sprintf("%v", this.Expire) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Invitecode:` + fmt.Sprintf("%v", this.Invitecode) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Round:` + fmt.Sprintf("%v", this.Round) + `,`,
		`Ante:` + fmt.Sprintf("%v", this.Ante) + `,`,
		`Chat:` + fmt.Sprintf("%v", this.Chat) + `,`,
		`Dealer:` + fmt.Sprintf("%v", this.Dealer) + `,`,
		`Ctime:` + fmt.Sprintf("%v", this.Ctime) + `,`,
		`Xi:` + fmt.Sprintf("%v", this.Xi) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringVo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UserData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomtype", wireType)
			}
			m.Roomtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitecode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitecode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Agent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Give", wireType)
			}
			m.Give = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Give |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bank", wireType)
			}
			m.Bank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bank |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Activity{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vip == nil {
				m.Vip = &VipInfo{}
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			m.Chat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Activity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Activity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Activity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Firstpay", wireType)
			}
			m.Firstpay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Firstpay |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relieve", wireType)
			}
			m.Relieve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Relieve |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bankrupt", wireType)
			}
			m.Bankrupt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bankrupt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prizedraw", wireType)
			}
			m.Prizedraw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Prizedraw |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leftdraw", wireType)
			}
			m.Leftdraw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leftdraw |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kicktimes", wireType)
			}
			m.Kicktimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kicktimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Niu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Niu = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vip == nil {
				m.Vip = &VipInfo{}
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dan == nil {
				m.Dan = &DanCombat{}
			}
			if err := m.Dan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			m.Chat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitecode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitecode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			m.Card = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Card |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xi", wireType)
			}
			m.Xi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			m.Draw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Draw |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discard", wireType)
			}
			m.Discard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discard |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			m.Players = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Players |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomBets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomBets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomBets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bets", wireType)
			}
			m.Bets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bets = append(m.Bets, &RoomBets{})
			if err := m.Bets[len(m.Bets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vip == nil {
				m.Vip = &VipInfo{}
			}
			if err := m.Vip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			m.Chat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pond", wireType)
			}
			m.Pond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			m.Timer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerNum", wireType)
			}
			m.DealerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DealerNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftDealerNum", wireType)
			}
			m.LeftDealerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftDealerNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeRoomOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeRoomOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeRoomOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RoomScore{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pond", wireType)
			}
			m.Pond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClassicOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassicOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassicOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bets", wireType)
			}
			m.Bets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OverList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OverList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OverList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bets", wireType)
			}
			m.Bets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bets |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Agree = append(m.Agree, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Agree = append(m.Agree, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Agree", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Disagree = append(m.Disagree, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Disagree = append(m.Disagree, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Disagree", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			m.Chat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitecode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitecode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRound", wireType)
			}
			m.TotalRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRound |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &OverList{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DealerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DealerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DealerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeTrendList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeTrendList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeTrendList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &FreeTrend{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreeTrend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreeTrend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreeTrend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrizeCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrizeCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrizeCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			m.Card = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Card |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Handcards = append(m.Handcards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Handcards = append(m.Handcards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Handcards", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Kancards = append(m.Kancards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Kancards = append(m.Kancards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Kancards", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Outcards = append(m.Outcards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Outcards = append(m.Outcards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Outcards", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Chowcards = append(m.Chowcards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Chowcards = append(m.Chowcards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Chowcards", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pongcards = append(m.Pongcards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pongcards = append(m.Pongcards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pongcards", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ticards = append(m.Ticards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVo
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ticards = append(m.Ticards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomSeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomSeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomSeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZiRoomOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZiRoomOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZiRoomOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DanOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DanOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DanOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Combat == nil {
				m.Combat = &DanCombat{}
			}
			if err := m.Combat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZiRoomRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZiRoomRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZiRoomRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZiRecordList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZiRecordList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZiRecordList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &ZiRoomInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seats = append(m.Seats, &RoomSeat{})
			if err := m.Seats[len(m.Seats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &ZiRoomRound{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZiRoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZiRoomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZiRoomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roomid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtype", wireType)
			}
			m.Rtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitecode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invitecode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chat", wireType)
			}
			m.Chat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dealer", wireType)
			}
			m.Dealer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dealer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xi", wireType)
			}
			m.Xi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Xi |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthVo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVo   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("vo.proto", fileDescriptorVo) }

var fileDescriptorVo = []byte{
	// 1509 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcd, 0x8e, 0x1b, 0x45,
	0x10, 0xde, 0xf9, 0xb1, 0x3d, 0x6e, 0xaf, 0xb3, 0x9b, 0x21, 0x42, 0xa3, 0x28, 0x18, 0x33, 0x80,
	0x94, 0x03, 0x8a, 0x44, 0x38, 0x70, 0x26, 0xbb, 0x42, 0x20, 0x11, 0x88, 0x26, 0x90, 0x43, 0xc4,
	0xa5, 0xed, 0xe9, 0xdd, 0x6d, 0xd6, 0x9e, 0x1e, 0xcd, 0xb4, 0x9d, 0x5d, 0x90, 0x10, 0x0f, 0xc0,
	0x81, 0x17, 0x80, 0x0b, 0x48, 0x20, 0x8e, 0x88, 0x87, 0x40, 0x1c, 0x50, 0x8e, 0x1c, 0x89, 0xb9,
	0x20, 0xc4, 0x21, 0x2f, 0x80, 0x84, 0xaa, 0xfa, 0x67, 0xda, 0xbb, 0xb3, 0xfc, 0x09, 0xc8, 0x8a,
	0x5b, 0x57, 0x57, 0x8f, 0xfb, 0xeb, 0xaa, 0xfa, 0xbe, 0xea, 0x36, 0x89, 0x96, 0xe2, 0x5a, 0x59,
	0x09, 0x29, 0x62, 0xbf, 0x9c, 0x5c, 0xee, 0x97, 0x8b, 0x89, 0x32, 0xd3, 0x5f, 0x7d, 0x12, 0xbd,
	0x55, 0xb3, 0x6a, 0x97, 0x4a, 0x1a, 0x3f, 0x4e, 0xba, 0x8b, 0x9a, 0x55, 0x3c, 0x4f, 0xbc, 0xb1,
	0x77, 0xb5, 0x9f, 0x69, 0x2b, 0xbe, 0x4c, 0xa2, 0x82, 0x4f, 0x0f, 0x0b, 0x3a, 0x67, 0x89, 0x8f,
	0x1e, 0x6b, 0xc7, 0x97, 0x48, 0xa7, 0x3c, 0x10, 0x05, 0x4b, 0x02, 0x74, 0x28, 0x23, 0xde, 0x26,
	0x41, 0xcd, 0x8e, 0x92, 0x70, 0xec, 0x5d, 0x1d, 0x66, 0x30, 0xd4, 0xeb, 0xa4, 0x48, 0x3a, 0x76,
	0x9d, 0x14, 0x71, 0x4c, 0xc2, 0xa9, 0xe0, 0x45, 0xd2, 0xc5, 0x85, 0x38, 0x8e, 0x13, 0xd2, 0xcb,
	0x39, 0x9d, 0x8b, 0x22, 0x4f, 0x7a, 0x38, 0x6d, 0x4c, 0xc0, 0x51, 0x09, 0x31, 0x97, 0xc7, 0x25,
	0x4b, 0x22, 0x74, 0x59, 0x1b, 0xb0, 0xc3, 0x98, 0xe7, 0x49, 0x5f, 0x61, 0x57, 0x56, 0x3c, 0x22,
	0x84, 0x17, 0x4b, 0x2e, 0xd9, 0x54, 0xe4, 0x2c, 0x21, 0xe8, 0x73, 0x66, 0x00, 0x17, 0xdd, 0x67,
	0x85, 0x4c, 0x06, 0x0a, 0x17, 0x1a, 0x80, 0x6b, 0x9f, 0x2f, 0x59, 0xb2, 0xa9, 0x70, 0xc1, 0x18,
	0xe6, 0x26, 0xb4, 0x38, 0x4c, 0x86, 0x6a, 0x0e, 0xc6, 0xf1, 0x98, 0x84, 0x39, 0x95, 0x34, 0xb9,
	0x30, 0xf6, 0xae, 0x0e, 0xae, 0x6f, 0x5e, 0x2b, 0x27, 0xd7, 0x5e, 0x9a, 0x4a, 0xbe, 0xe4, 0xf2,
	0x38, 0x43, 0x4f, 0xfc, 0x04, 0x09, 0x96, 0xbc, 0x4c, 0xb6, 0x70, 0xc1, 0x00, 0x16, 0xdc, 0xe1,
	0xe5, 0xab, 0xc5, 0x9e, 0xc8, 0x60, 0x3e, 0xfd, 0xd2, 0x53, 0xf1, 0x87, 0x99, 0xf3, 0x1e, 0xff,
	0xf4, 0x43, 0x8f, 0x44, 0x99, 0x10, 0x73, 0x03, 0x56, 0x07, 0xdc, 0x5b, 0x0b, 0xf8, 0x25, 0xd2,
	0xa9, 0x30, 0x43, 0x3e, 0x7e, 0xac, 0x0c, 0x9c, 0x45, 0xfc, 0x1a, 0x66, 0x65, 0xc0, 0x4f, 0xc5,
	0xa2, 0x90, 0x1a, 0xa8, 0x32, 0x00, 0x14, 0x2d, 0x24, 0x43, 0xa4, 0xc3, 0x0c, 0xc7, 0x08, 0xf4,
	0x80, 0x4a, 0x0b, 0xf4, 0x80, 0xca, 0xf4, 0x6b, 0x8f, 0x44, 0x26, 0xda, 0x10, 0xa3, 0x3d, 0x5e,
	0xd5, 0xb2, 0xa4, 0xc7, 0x08, 0x68, 0x98, 0x59, 0x1b, 0x4e, 0x54, 0xb1, 0x19, 0x67, 0x4b, 0x03,
	0xca, 0x98, 0xf0, 0x15, 0xe4, 0xb1, 0x5a, 0x94, 0x12, 0x91, 0x0d, 0x33, 0x6b, 0xc7, 0x57, 0x48,
	0xbf, 0xac, 0xf8, 0xbb, 0x2c, 0xaf, 0xe8, 0x3d, 0x0d, 0xb0, 0x99, 0x80, 0x2f, 0x67, 0x6c, 0x4f,
	0xa2, 0x53, 0x01, 0xb5, 0x36, 0x7c, 0x79, 0xc8, 0xa7, 0x87, 0x92, 0xcf, 0x59, 0xad, 0x11, 0x37,
	0x13, 0xe9, 0x8b, 0xa4, 0xa7, 0x4b, 0x00, 0xce, 0x3f, 0x63, 0x4b, 0x36, 0xd3, 0x88, 0x95, 0x01,
	0x91, 0x2d, 0x16, 0xf3, 0x09, 0xab, 0x34, 0x5a, 0x6d, 0xa5, 0x9f, 0x05, 0x2a, 0xfc, 0x50, 0x2f,
	0xe7, 0x9e, 0xab, 0x31, 0x09, 0x6b, 0x46, 0xa5, 0xe6, 0x29, 0x8e, 0xb1, 0x08, 0x18, 0xcd, 0x8f,
	0x91, 0xa2, 0x51, 0xa6, 0x0c, 0x98, 0xad, 0xa7, 0xa2, 0x52, 0xe4, 0xec, 0x64, 0xca, 0x80, 0xf3,
	0xe5, 0x8c, 0xce, 0x58, 0x85, 0xc4, 0x1c, 0x66, 0xda, 0x02, 0xb4, 0x13, 0x26, 0x35, 0x31, 0x61,
	0x88, 0x45, 0x44, 0xab, 0xbc, 0x4e, 0x86, 0xe3, 0x00, 0x8b, 0x08, 0x0c, 0x58, 0x57, 0x2c, 0xe6,
	0x48, 0xcc, 0x61, 0x06, 0x43, 0x9c, 0xe1, 0x0b, 0x64, 0x62, 0x94, 0xc1, 0xd0, 0x70, 0x73, 0xbb,
	0x9d, 0x9b, 0xf0, 0xc3, 0x4b, 0x3a, 0x5b, 0xb0, 0xe4, 0xa2, 0xca, 0x0e, 0x1a, 0xf1, 0x93, 0x24,
	0xc8, 0x69, 0x91, 0xc4, 0xf8, 0xd1, 0x10, 0x3e, 0xda, 0xa5, 0xc5, 0x8e, 0x98, 0x4f, 0xa8, 0xcc,
	0xc0, 0x93, 0x7e, 0xa7, 0xd3, 0x64, 0x24, 0xf5, 0xd1, 0xb2, 0x04, 0x10, 0xb0, 0xa3, 0x92, 0x57,
	0x4c, 0x67, 0x48, 0x5b, 0x27, 0x84, 0x31, 0x3a, 0x25, 0x8c, 0x4d, 0x02, 0xfa, 0x6b, 0x09, 0x00,
	0x8c, 0x62, 0x51, 0xe4, 0x98, 0x2e, 0x40, 0x0e, 0x86, 0x53, 0x8e, 0x83, 0xb5, 0x72, 0x84, 0xe4,
	0x4a, 0x2a, 0x8d, 0x92, 0x2a, 0x03, 0x71, 0xd2, 0x2a, 0x37, 0x52, 0x0a, 0xe3, 0xf8, 0x02, 0xf1,
	0x8f, 0xb8, 0xce, 0x97, 0x7f, 0xc4, 0x61, 0x0d, 0x92, 0x6b, 0x4b, 0xad, 0x41, 0x62, 0x61, 0xb9,
	0xd5, 0xf8, 0xe9, 0xb6, 0x29, 0x37, 0x34, 0x6d, 0xb9, 0x5d, 0x74, 0xca, 0xad, 0xe1, 0x51, 0xec,
	0xf2, 0x08, 0x30, 0x49, 0x21, 0xe9, 0x2c, 0x79, 0x4c, 0x61, 0x42, 0x03, 0x7e, 0xbb, 0x9c, 0xd1,
	0x63, 0x56, 0xd5, 0xc9, 0x25, 0xf5, 0xdb, 0xda, 0x4c, 0xaf, 0xab, 0x7c, 0xde, 0x60, 0xb2, 0xb6,
	0xfb, 0x78, 0xce, 0x3e, 0xd0, 0x18, 0x98, 0xac, 0x75, 0x2a, 0x71, 0x9c, 0x7e, 0xee, 0x93, 0xe8,
	0xe5, 0x8a, 0xb1, 0xff, 0x19, 0x57, 0x35, 0xfb, 0x48, 0xc3, 0xbe, 0xb1, 0x3e, 0xfc, 0x60, 0x1c,
	0x98, 0x0e, 0x68, 0x82, 0xa5, 0x42, 0x61, 0x58, 0xb6, 0x79, 0x46, 0x07, 0xfc, 0x59, 0x47, 0x0a,
	0xbe, 0x3a, 0x1f, 0x74, 0xd1, 0x65, 0xdf, 0x5b, 0x2b, 0xfb, 0x26, 0x87, 0xd1, 0x5a, 0x0e, 0x4d,
	0xa4, 0xfb, 0x4e, 0xa4, 0x63, 0x12, 0x96, 0xc2, 0x32, 0x04, 0xc7, 0x0d, 0x11, 0x06, 0x2e, 0x11,
	0xa0, 0x14, 0xf9, 0x9c, 0x55, 0x86, 0x1e, 0x68, 0x40, 0xff, 0x50, 0xbb, 0xbe, 0xbe, 0x98, 0x6b,
	0x8e, 0x34, 0x13, 0xf1, 0x33, 0x64, 0x08, 0x9d, 0x66, 0xd7, 0xae, 0x50, 0x9c, 0x59, 0x9f, 0x6c,
	0xea, 0x62, 0xcb, 0xa9, 0x8b, 0x74, 0xa9, 0x4a, 0xf9, 0x8d, 0x25, 0xab, 0x5a, 0x4b, 0xd9, 0x6a,
	0xa9, 0xef, 0x6a, 0xa9, 0x15, 0xc2, 0xc0, 0x15, 0x42, 0x4b, 0xa3, 0x50, 0xe9, 0xb6, 0xa2, 0x91,
	0x55, 0xf3, 0x8e, 0xa3, 0xe6, 0xe9, 0xc7, 0x1e, 0xd9, 0x34, 0x49, 0xfe, 0xaf, 0x37, 0x8f, 0x9f,
	0x22, 0xe1, 0x8c, 0xd7, 0x90, 0xe6, 0xc0, 0x48, 0x36, 0xe0, 0xb8, 0x0d, 0xce, 0x0c, 0x5d, 0xe9,
	0x82, 0xf4, 0xed, 0x54, 0x2b, 0xb6, 0x26, 0xfd, 0xfe, 0x29, 0x7d, 0xc3, 0x1d, 0x03, 0x77, 0x47,
	0x53, 0x00, 0xa1, 0x53, 0x00, 0xa6, 0x50, 0x3a, 0x4d, 0xa1, 0xa4, 0x9f, 0x7a, 0x64, 0xb0, 0x33,
	0xa3, 0x75, 0xcd, 0xa7, 0x67, 0x46, 0xe5, 0x77, 0x76, 0x56, 0xd1, 0x0a, 0x5a, 0xa3, 0x15, 0xba,
	0xd1, 0x32, 0x0a, 0xd5, 0x69, 0x14, 0xaa, 0x41, 0xde, 0x3d, 0x81, 0x1c, 0x51, 0xf6, 0x1c, 0x94,
	0xbf, 0x78, 0x24, 0x02, 0x78, 0xaf, 0xf1, 0x5a, 0xfe, 0x6b, 0x10, 0x6d, 0x5b, 0xe9, 0xb8, 0x6d,
	0xa5, 0x1d, 0xe4, 0x59, 0x1c, 0x35, 0xc7, 0x8c, 0x9c, 0x63, 0xba, 0x1a, 0xdb, 0x6f, 0xd5, 0x58,
	0x29, 0xf4, 0xb3, 0x40, 0x73, 0xe4, 0x96, 0xe2, 0xc8, 0x1d, 0x21, 0xd9, 0x59, 0x65, 0x4a, 0xf7,
	0x2b, 0xc6, 0x4c, 0x99, 0xa2, 0x01, 0xfb, 0xe4, 0xbc, 0x56, 0x0e, 0x75, 0x5c, 0x6b, 0xa7, 0x9f,
	0xf8, 0x84, 0x64, 0x6c, 0x2a, 0xaa, 0x1c, 0x43, 0xf8, 0xe8, 0x45, 0x6e, 0xbd, 0xf7, 0xf7, 0x4e,
	0xf5, 0xfe, 0x11, 0x21, 0x48, 0xa8, 0x0c, 0x33, 0xa2, 0xc2, 0xe9, 0xcc, 0x38, 0x09, 0xef, 0x9f,
	0x4a, 0x38, 0x48, 0x98, 0xb9, 0x1b, 0xa0, 0x01, 0x2d, 0x02, 0xf9, 0xe7, 0xb4, 0x08, 0x53, 0x4e,
	0x9a, 0x7e, 0xef, 0x10, 0xa2, 0x94, 0xcb, 0xc4, 0xe7, 0x6f, 0xb6, 0x4b, 0x29, 0x9c, 0x76, 0xe9,
	0xb4, 0xc1, 0xd0, 0xa9, 0xe6, 0x57, 0xc8, 0x10, 0x94, 0xe8, 0xcd, 0x8a, 0x15, 0x2a, 0x1d, 0xb6,
	0xf2, 0x3c, 0xb7, 0xf2, 0x8c, 0x68, 0xf8, 0x8d, 0x68, 0xd8, 0xcf, 0x34, 0xea, 0xe7, 0x49, 0xdf,
	0x4e, 0xb5, 0x56, 0xca, 0x36, 0x09, 0xee, 0xf1, 0x02, 0xb1, 0x46, 0x19, 0x0c, 0xd3, 0x9b, 0xa4,
	0x7f, 0x0b, 0x9e, 0x10, 0x3b, 0xfa, 0xce, 0x82, 0x57, 0x19, 0xcf, 0xb9, 0x05, 0xb5, 0xd7, 0x40,
	0x73, 0x93, 0x09, 0xd6, 0x5e, 0x04, 0xdf, 0xea, 0x07, 0xd9, 0x8e, 0x7b, 0x05, 0x72, 0x11, 0x5c,
	0x21, 0xfd, 0x03, 0x5a, 0xe4, 0xae, 0xac, 0x36, 0x13, 0x10, 0xd0, 0x43, 0x5a, 0xb8, 0x14, 0xb5,
	0x36, 0xf8, 0xc4, 0x42, 0x2a, 0x5f, 0xa8, 0x7c, 0xc6, 0x86, 0x5f, 0x9d, 0x1e, 0x88, 0x7b, 0xca,
	0xd9, 0x51, 0xbf, 0x6a, 0x27, 0xf0, 0xdd, 0x24, 0x8a, 0x7d, 0xe5, 0xed, 0x2a, 0xaf, 0x9d, 0x80,
	0x5b, 0x88, 0xe4, 0xca, 0xd7, 0x43, 0x9f, 0x31, 0xd3, 0xf7, 0xd5, 0x59, 0x6e, 0xeb, 0x2b, 0xd5,
	0x9f, 0x56, 0x19, 0xb7, 0x2c, 0x82, 0xb3, 0xca, 0x22, 0x74, 0xcb, 0xa2, 0xbd, 0x47, 0x1d, 0x11,
	0x72, 0x97, 0xff, 0x51, 0x83, 0x52, 0x4d, 0xc7, 0x6f, 0x6d, 0x3a, 0x41, 0x9b, 0x90, 0x3a, 0xa5,
	0x07, 0x27, 0x28, 0x05, 0x2f, 0xb4, 0x10, 0x77, 0x32, 0x6d, 0xa5, 0x6f, 0x93, 0xde, 0x2e, 0x2d,
	0xfe, 0x72, 0x07, 0x78, 0x96, 0x74, 0xa7, 0xf8, 0xee, 0xc0, 0x9d, 0x4f, 0x3d, 0x46, 0xb4, 0x33,
	0xbd, 0x49, 0x06, 0xea, 0x5c, 0x8a, 0xbb, 0x67, 0x1c, 0x4c, 0x1d, 0xc1, 0x77, 0x8f, 0x60, 0x89,
	0x11, 0x38, 0xc4, 0x48, 0xdf, 0x23, 0x9b, 0x77, 0xb9, 0xa3, 0x66, 0x29, 0x09, 0x79, 0xb1, 0x27,
	0xf0, 0xf7, 0x06, 0xd7, 0x2f, 0x00, 0x06, 0xb5, 0x1d, 0x5e, 0xf1, 0xd0, 0x17, 0xa7, 0xa4, 0x03,
	0xfb, 0xd4, 0x9a, 0x4d, 0xf6, 0x96, 0x08, 0xb9, 0xce, 0x94, 0x2b, 0x7e, 0x5a, 0x13, 0x2e, 0xc0,
	0x25, 0x5b, 0xcd, 0xef, 0x20, 0x6c, 0x4d, 0xb9, 0xaf, 0x7c, 0x93, 0xa4, 0x7f, 0xec, 0x3f, 0x88,
	0xe6, 0x7d, 0x14, 0xae, 0xbd, 0x8f, 0xac, 0xc2, 0x76, 0x5c, 0x85, 0x5d, 0x57, 0xce, 0x6e, 0xdb,
	0xab, 0x49, 0xe7, 0xaa, 0x77, 0x52, 0x19, 0x2b, 0x47, 0x4c, 0xb5, 0xc8, 0x18, 0xbd, 0xee, 0xb7,
	0xe8, 0x35, 0x69, 0xbd, 0x94, 0x0e, 0x4e, 0xbe, 0xc5, 0x94, 0xde, 0x6e, 0xba, 0x7a, 0xab, 0x5e,
	0x52, 0x43, 0xf3, 0x92, 0xba, 0xf1, 0xdc, 0xfd, 0x07, 0xa3, 0x8d, 0xef, 0x1f, 0x8c, 0x36, 0x1e,
	0x3e, 0x18, 0x79, 0x1f, 0xac, 0x46, 0xde, 0x17, 0xab, 0x91, 0xf7, 0xcd, 0x6a, 0xe4, 0xdd, 0x5f,
	0x8d, 0xbc, 0x1f, 0x56, 0x23, 0xef, 0xa7, 0xd5, 0x68, 0xe3, 0xe1, 0x6a, 0xe4, 0x7d, 0xf4, 0xe3,
	0x68, 0x63, 0xd2, 0xc5, 0x3f, 0x06, 0x5f, 0xf8, 0x2d, 0x00, 0x00, 0xff, 0xff, 0x74, 0x34, 0x1f,
	0x59, 0x33, 0x14, 0x00, 0x00,
}
