// Code generated by protoc-gen-gogo.
// source: betting.proto
// DO NOT EDIT!

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		betting.proto
		buy.proto
		chat.proto
		classic.proto
		code.proto
		dan.proto
		data.proto
		free.proto
		logger.proto
		login.proto
		lottery.proto
		mail.proto
		niu.proto
		phz.proto
		prize.proto
		protos.proto
		pub.proto
		robot.proto
		role.proto
		room.proto
		user.proto
		vo.proto
		web.proto

	It has these top-level messages:
		CBettingInfo
		SBettingInfo
		Betting
		JackpotInfo
		CBetting
		SBetting
		SPushJackpot
		Jackpot
		SPushBetting
		JackpotOver
		JackpotSelf
		SPushNewBetting
		CBettingRecord
		SBettingRecord
		RecordBettings
		RecordBetting
		CBuy
		SBuy
		CWxpayOrder
		SWxpayOrder
		CWxpayQuery
		SWxpayQuery
		CApplePay
		SApplePay
		CShop
		SShop
		Shop
		CChatText
		SChatText
		CChatVoice
		SChatVoice
		SBroadcast
		CNotice
		SNotice
		Notice
		CEnterClassicRoom
		SEnterClassicRoom
		SClassicGameover
		CGetPrize
		SGetPrize
		CPrizeCards
		SPrizeCards
		CDanInfo
		SDanInfo
		CQualifying
		SQualifying
		CDanRanking
		SDanRanking
		SDanNotice
		CEnterFreeRoom
		SEnterFreeRoom
		SFreeCamein
		CFreeDealer
		SFreeDealer
		CDealerList
		SDealerList
		CFreeSit
		SFreeSit
		CFreeBet
		SFreeBet
		SFreeGamestart
		SFreeGameover
		CFreeTrend
		SFreeTrend
		LogRegist
		LogLogin
		LogLogout
		LogDiamond
		LogCoin
		LogBuildAgency
		LogOnline
		LogSetHand
		CLogin
		SLogin
		CRegist
		SRegist
		CWxLogin
		SWxLogin
		SLoginOut
		CLotteryInfo
		SLotteryInfo
		Lottery
		CLottery
		SLottery
		SMailNotice
		CMailList
		SMailList
		CDeleteMail
		SDeleteMail
		CGetMailItem
		SGetMailItem
		Items
		MailList
		CEnterRoom
		SEnterRoom
		CCreateRoom
		SCreateRoom
		SCamein
		SDraw
		CDealer
		SDealer
		SPushDealer
		CBet
		SBet
		CNiu
		SNiu
		SGameover
		CGameRecord
		SGameRecord
		CEnterZiRoom
		SEnterZiRoom
		CCreateZiRoom
		SCreateZiRoom
		SZiCamein
		SZiGameover
		CZiGameRecord
		SZiGameRecord
		SPushDeal
		SPushDealerDeal
		SPushDealerBu
		SPushPaoHu
		SPushDraw
		CPushDiscard
		SPushDiscard
		SPushAuto
		COperate
		SOperate
		SPushStatus
		CPrizeList
		SPrizeList
		CPrizeDraw
		SPrizeDraw
		CPrizeBox
		SPrizeBox
		Prize
		CBankrupts
		SBankrupts
		CClassicList
		SClassicList
		Classic
		CVipList
		SVipList
		Vip
		SPushVip
		Request
		Response
		GateConnect
		GateConnected
		GateDisconnect
		GateDisconnected
		HallConnect
		HallConnected
		ServeStop
		ServeStoped
		DanSeason
		DanRanking
		DanTaskList
		DanList
		DanInfo
		DanCombat
		RobotMsg
		RobotLogin
		RobotReLogin
		RobotLogout
		SetLogin
		SetLogined
		LoginGate
		LoginedGate
		LoginHall
		LoginedHall
		Login
		Logined
		LoginElse
		LoginedElse
		Logout
		Logouted
		SyncUser
		ChangeCurrency
		GetUserid
		GotUserid
		GetUniqueid
		GotUniqueid
		RoleLogin
		RoleLogined
		RoleRegist
		RoleRegisted
		WxLogin
		WxLogined
		NewMail
		NewMailList
		DeleteMail
		GetMailItem
		CLeave
		SLeave
		CKick
		SKick
		CReady
		SReady
		CLaunchVote
		SLaunchVote
		CVote
		SVote
		SVoteResult
		SPubDraw
		CRoomList
		SRoomList
		CConfig
		SConfig
		CUserData
		SUserData
		CGetCurrency
		SGetCurrency
		CBuildAgent
		SBuildAgent
		SPushCurrency
		CBank
		SBank
		CPing
		SPing
		UserData
		UserInfo
		RoomInfo
		Activity
		VipInfo
		RoomUser
		RoomData
		RoomBets
		FreeUser
		FreeRoom
		RoomOver
		FreeRoomOver
		RoomScore
		ClassicOver
		OverList
		RoomVote
		RecordList
		DealerList
		FreeTrendList
		FreeTrend
		PrizeCard
		RoomCard
		RoomSeat
		ZiRoomOver
		DanOver
		ZiRoomRound
		ZiRecordList
		ZiRoomInfo
		SyncConfig
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 疯狂投注
type CBettingInfo struct {
	Code uint32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *CBettingInfo) Reset()                    { *m = CBettingInfo{} }
func (*CBettingInfo) ProtoMessage()               {}
func (*CBettingInfo) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{0} }

func (m *CBettingInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type SBettingInfo struct {
	Code   uint32         `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Index  string         `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	Status *Betting       `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	List   []*JackpotInfo `protobuf:"bytes,4,rep,name=list" json:"list,omitempty"`
	Error  ErrCode        `protobuf:"varint,5,opt,name=error,proto3,enum=pb.ErrCode" json:"error,omitempty"`
}

func (m *SBettingInfo) Reset()                    { *m = SBettingInfo{} }
func (*SBettingInfo) ProtoMessage()               {}
func (*SBettingInfo) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{1} }

func (m *SBettingInfo) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SBettingInfo) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *SBettingInfo) GetStatus() *Betting {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SBettingInfo) GetList() []*JackpotInfo {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *SBettingInfo) GetError() ErrCode {
	if m != nil {
		return m.Error
	}
	return OK
}

// 投注状态
type Betting struct {
	Times uint32 `protobuf:"varint,1,opt,name=times,proto3" json:"times,omitempty"`
	State uint32 `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *Betting) Reset()                    { *m = Betting{} }
func (*Betting) ProtoMessage()               {}
func (*Betting) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{2} }

func (m *Betting) GetTimes() uint32 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *Betting) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

// 奖池
type JackpotInfo struct {
	Seat   uint32  `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Odds   float32 `protobuf:"fixed32,2,opt,name=odds,proto3" json:"odds,omitempty"`
	Number uint32  `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *JackpotInfo) Reset()                    { *m = JackpotInfo{} }
func (*JackpotInfo) ProtoMessage()               {}
func (*JackpotInfo) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{3} }

func (m *JackpotInfo) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *JackpotInfo) GetOdds() float32 {
	if m != nil {
		return m.Odds
	}
	return 0
}

func (m *JackpotInfo) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 疯狂投注押注
type CBetting struct {
	Code   uint32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Seat   uint32 `protobuf:"varint,2,opt,name=seat,proto3" json:"seat,omitempty"`
	Number uint32 `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *CBetting) Reset()                    { *m = CBetting{} }
func (*CBetting) ProtoMessage()               {}
func (*CBetting) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{4} }

func (m *CBetting) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CBetting) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *CBetting) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

type SBetting struct {
	Code   uint32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Seat   uint32  `protobuf:"varint,2,opt,name=seat,proto3" json:"seat,omitempty"`
	Number uint32  `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
	Error  ErrCode `protobuf:"varint,4,opt,name=error,proto3,enum=pb.ErrCode" json:"error,omitempty"`
}

func (m *SBetting) Reset()                    { *m = SBetting{} }
func (*SBetting) ProtoMessage()               {}
func (*SBetting) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{5} }

func (m *SBetting) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SBetting) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *SBetting) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *SBetting) GetError() ErrCode {
	if m != nil {
		return m.Error
	}
	return OK
}

// 奖池更新广播
type SPushJackpot struct {
	Code uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	List []*Jackpot `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
}

func (m *SPushJackpot) Reset()                    { *m = SPushJackpot{} }
func (*SPushJackpot) ProtoMessage()               {}
func (*SPushJackpot) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{6} }

func (m *SPushJackpot) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SPushJackpot) GetList() []*Jackpot {
	if m != nil {
		return m.List
	}
	return nil
}

// 奖池
type Jackpot struct {
	Seat   uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Number uint32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *Jackpot) Reset()                    { *m = Jackpot{} }
func (*Jackpot) ProtoMessage()               {}
func (*Jackpot) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{7} }

func (m *Jackpot) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *Jackpot) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 开奖结果
type SPushBetting struct {
	Code   uint32         `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Cards  []uint32       `protobuf:"varint,2,rep,packed,name=cards" json:"cards,omitempty"`
	Niu    uint32         `protobuf:"varint,3,opt,name=niu,proto3" json:"niu,omitempty"`
	Number int32          `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	List   []*JackpotSelf `protobuf:"bytes,5,rep,name=list" json:"list,omitempty"`
	Info   []*JackpotOver `protobuf:"bytes,6,rep,name=info" json:"info,omitempty"`
	Status *Betting       `protobuf:"bytes,7,opt,name=status" json:"status,omitempty"`
}

func (m *SPushBetting) Reset()                    { *m = SPushBetting{} }
func (*SPushBetting) ProtoMessage()               {}
func (*SPushBetting) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{8} }

func (m *SPushBetting) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SPushBetting) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *SPushBetting) GetNiu() uint32 {
	if m != nil {
		return m.Niu
	}
	return 0
}

func (m *SPushBetting) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *SPushBetting) GetList() []*JackpotSelf {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *SPushBetting) GetInfo() []*JackpotOver {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *SPushBetting) GetStatus() *Betting {
	if m != nil {
		return m.Status
	}
	return nil
}

// 奖池
type JackpotOver struct {
	Seat  uint32  `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Win   bool    `protobuf:"varint,2,opt,name=win,proto3" json:"win,omitempty"`
	Odds  float32 `protobuf:"fixed32,3,opt,name=odds,proto3" json:"odds,omitempty"`
	Count uint32  `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *JackpotOver) Reset()                    { *m = JackpotOver{} }
func (*JackpotOver) ProtoMessage()               {}
func (*JackpotOver) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{9} }

func (m *JackpotOver) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *JackpotOver) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

func (m *JackpotOver) GetOdds() float32 {
	if m != nil {
		return m.Odds
	}
	return 0
}

func (m *JackpotOver) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// 奖池
type JackpotSelf struct {
	Seat   uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Ante   uint32 `protobuf:"varint,2,opt,name=ante,proto3" json:"ante,omitempty"`
	Number int32  `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *JackpotSelf) Reset()                    { *m = JackpotSelf{} }
func (*JackpotSelf) ProtoMessage()               {}
func (*JackpotSelf) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{10} }

func (m *JackpotSelf) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *JackpotSelf) GetAnte() uint32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *JackpotSelf) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 新一轮开始广播
type SPushNewBetting struct {
	Code   uint32   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Index  string   `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	Status *Betting `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *SPushNewBetting) Reset()                    { *m = SPushNewBetting{} }
func (*SPushNewBetting) ProtoMessage()               {}
func (*SPushNewBetting) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{11} }

func (m *SPushNewBetting) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SPushNewBetting) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *SPushNewBetting) GetStatus() *Betting {
	if m != nil {
		return m.Status
	}
	return nil
}

// 疯狂投注记录
type CBettingRecord struct {
	Code uint32 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Page uint32 `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *CBettingRecord) Reset()                    { *m = CBettingRecord{} }
func (*CBettingRecord) ProtoMessage()               {}
func (*CBettingRecord) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{12} }

func (m *CBettingRecord) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CBettingRecord) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

type SBettingRecord struct {
	Code uint32            `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	List []*RecordBettings `protobuf:"bytes,2,rep,name=list" json:"list,omitempty"`
}

func (m *SBettingRecord) Reset()                    { *m = SBettingRecord{} }
func (*SBettingRecord) ProtoMessage()               {}
func (*SBettingRecord) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{13} }

func (m *SBettingRecord) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SBettingRecord) GetList() []*RecordBettings {
	if m != nil {
		return m.List
	}
	return nil
}

// 个人投注记录列表
type RecordBettings struct {
	Index  string           `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Cards  []uint32         `protobuf:"varint,2,rep,packed,name=cards" json:"cards,omitempty"`
	Niu    uint32           `protobuf:"varint,3,opt,name=niu,proto3" json:"niu,omitempty"`
	Seats  []uint32         `protobuf:"varint,4,rep,packed,name=seats" json:"seats,omitempty"`
	Number int32            `protobuf:"varint,5,opt,name=number,proto3" json:"number,omitempty"`
	List   []*RecordBetting `protobuf:"bytes,6,rep,name=list" json:"list,omitempty"`
}

func (m *RecordBettings) Reset()                    { *m = RecordBettings{} }
func (*RecordBettings) ProtoMessage()               {}
func (*RecordBettings) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{14} }

func (m *RecordBettings) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *RecordBettings) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *RecordBettings) GetNiu() uint32 {
	if m != nil {
		return m.Niu
	}
	return 0
}

func (m *RecordBettings) GetSeats() []uint32 {
	if m != nil {
		return m.Seats
	}
	return nil
}

func (m *RecordBettings) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *RecordBettings) GetList() []*RecordBetting {
	if m != nil {
		return m.List
	}
	return nil
}

// 个人下注情况
type RecordBetting struct {
	Seat   uint32 `protobuf:"varint,1,opt,name=seat,proto3" json:"seat,omitempty"`
	Number uint32 `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *RecordBetting) Reset()                    { *m = RecordBetting{} }
func (*RecordBetting) ProtoMessage()               {}
func (*RecordBetting) Descriptor() ([]byte, []int) { return fileDescriptorBetting, []int{15} }

func (m *RecordBetting) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *RecordBetting) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func init() {
	proto.RegisterType((*CBettingInfo)(nil), "pb.CBettingInfo")
	proto.RegisterType((*SBettingInfo)(nil), "pb.SBettingInfo")
	proto.RegisterType((*Betting)(nil), "pb.Betting")
	proto.RegisterType((*JackpotInfo)(nil), "pb.JackpotInfo")
	proto.RegisterType((*CBetting)(nil), "pb.CBetting")
	proto.RegisterType((*SBetting)(nil), "pb.SBetting")
	proto.RegisterType((*SPushJackpot)(nil), "pb.SPushJackpot")
	proto.RegisterType((*Jackpot)(nil), "pb.Jackpot")
	proto.RegisterType((*SPushBetting)(nil), "pb.SPushBetting")
	proto.RegisterType((*JackpotOver)(nil), "pb.JackpotOver")
	proto.RegisterType((*JackpotSelf)(nil), "pb.JackpotSelf")
	proto.RegisterType((*SPushNewBetting)(nil), "pb.SPushNewBetting")
	proto.RegisterType((*CBettingRecord)(nil), "pb.CBettingRecord")
	proto.RegisterType((*SBettingRecord)(nil), "pb.SBettingRecord")
	proto.RegisterType((*RecordBettings)(nil), "pb.RecordBettings")
	proto.RegisterType((*RecordBetting)(nil), "pb.RecordBetting")
}
func (this *CBettingInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CBettingInfo)
	if !ok {
		that2, ok := that.(CBettingInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *SBettingInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SBettingInfo)
	if !ok {
		that2, ok := that.(SBettingInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *Betting) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Betting)
	if !ok {
		that2, ok := that.(Betting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Times != that1.Times {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *JackpotInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*JackpotInfo)
	if !ok {
		that2, ok := that.(JackpotInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Odds != that1.Odds {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *CBetting) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CBetting)
	if !ok {
		that2, ok := that.(CBetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *SBetting) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SBetting)
	if !ok {
		that2, ok := that.(SBetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *SPushJackpot) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SPushJackpot)
	if !ok {
		that2, ok := that.(SPushJackpot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *Jackpot) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Jackpot)
	if !ok {
		that2, ok := that.(Jackpot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *SPushBetting) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SPushBetting)
	if !ok {
		that2, ok := that.(SPushBetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Niu != that1.Niu {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	if len(this.Info) != len(that1.Info) {
		return false
	}
	for i := range this.Info {
		if !this.Info[i].Equal(that1.Info[i]) {
			return false
		}
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *JackpotOver) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*JackpotOver)
	if !ok {
		that2, ok := that.(JackpotOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Win != that1.Win {
		return false
	}
	if this.Odds != that1.Odds {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *JackpotSelf) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*JackpotSelf)
	if !ok {
		that2, ok := that.(JackpotSelf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Ante != that1.Ante {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *SPushNewBetting) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SPushNewBetting)
	if !ok {
		that2, ok := that.(SPushNewBetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *CBettingRecord) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CBettingRecord)
	if !ok {
		that2, ok := that.(CBettingRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Page != that1.Page {
		return false
	}
	return true
}
func (this *SBettingRecord) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SBettingRecord)
	if !ok {
		that2, ok := that.(SBettingRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *RecordBettings) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RecordBettings)
	if !ok {
		that2, ok := that.(RecordBettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.Niu != that1.Niu {
		return false
	}
	if len(this.Seats) != len(that1.Seats) {
		return false
	}
	for i := range this.Seats {
		if this.Seats[i] != that1.Seats[i] {
			return false
		}
	}
	if this.Number != that1.Number {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *RecordBetting) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RecordBetting)
	if !ok {
		that2, ok := that.(RecordBetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *CBettingInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.CBettingInfo{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SBettingInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pb.SBettingInfo{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Betting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.Betting{")
	s = append(s, "Times: "+fmt.Sprintf("%#v", this.Times)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JackpotInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.JackpotInfo{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Odds: "+fmt.Sprintf("%#v", this.Odds)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CBetting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.CBetting{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SBetting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.SBetting{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SPushJackpot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.SPushJackpot{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Jackpot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.Jackpot{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SPushBetting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&pb.SPushBetting{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Niu: "+fmt.Sprintf("%#v", this.Niu)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JackpotOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.JackpotOver{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Win: "+fmt.Sprintf("%#v", this.Win)+",\n")
	s = append(s, "Odds: "+fmt.Sprintf("%#v", this.Odds)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *JackpotSelf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.JackpotSelf{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Ante: "+fmt.Sprintf("%#v", this.Ante)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SPushNewBetting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.SPushNewBetting{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CBettingRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.CBettingRecord{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Page: "+fmt.Sprintf("%#v", this.Page)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SBettingRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.SBettingRecord{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecordBettings) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pb.RecordBettings{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "Niu: "+fmt.Sprintf("%#v", this.Niu)+",\n")
	s = append(s, "Seats: "+fmt.Sprintf("%#v", this.Seats)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RecordBetting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.RecordBetting{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBetting(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CBettingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CBettingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SBettingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SBettingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if len(m.Index) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBetting(dAtA, i, uint64(len(m.Index)))
		i += copy(dAtA[i:], m.Index)
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Status.Size()))
		n1, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBetting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Error != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *Betting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Betting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Times != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Times))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *JackpotInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JackpotInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Odds != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Betting(dAtA, i, uint32(math.Float32bits(float32(m.Odds))))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *CBetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CBetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if m.Seat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *SBetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SBetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if m.Seat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	if m.Error != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *SPushJackpot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SPushJackpot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBetting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Jackpot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Jackpot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *SPushBetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SPushBetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if len(m.Cards) > 0 {
		dAtA3 := make([]byte, len(m.Cards)*10)
		var j2 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBetting(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.Niu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Niu))
	}
	if m.Number != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintBetting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Info) > 0 {
		for _, msg := range m.Info {
			dAtA[i] = 0x32
			i++
			i = encodeVarintBetting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Status.Size()))
		n4, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *JackpotOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JackpotOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Win {
		dAtA[i] = 0x10
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Odds != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Betting(dAtA, i, uint32(math.Float32bits(float32(m.Odds))))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *JackpotSelf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JackpotSelf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Ante != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Ante))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *SPushNewBetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SPushNewBetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if len(m.Index) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBetting(dAtA, i, uint64(len(m.Index)))
		i += copy(dAtA[i:], m.Index)
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Status.Size()))
		n5, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CBettingRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CBettingRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *SBettingRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SBettingRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Code))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBetting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecordBettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordBettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBetting(dAtA, i, uint64(len(m.Index)))
		i += copy(dAtA[i:], m.Index)
	}
	if len(m.Cards) > 0 {
		dAtA7 := make([]byte, len(m.Cards)*10)
		var j6 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBetting(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.Niu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Niu))
	}
	if len(m.Seats) > 0 {
		dAtA9 := make([]byte, len(m.Seats)*10)
		var j8 int
		for _, num := range m.Seats {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBetting(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.Number != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0x32
			i++
			i = encodeVarintBetting(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RecordBetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordBetting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBetting(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func encodeFixed64Betting(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Betting(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintBetting(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CBettingInfo) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	return n
}

func (m *SBettingInfo) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovBetting(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBetting(uint64(l))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovBetting(uint64(l))
		}
	}
	if m.Error != 0 {
		n += 1 + sovBetting(uint64(m.Error))
	}
	return n
}

func (m *Betting) Size() (n int) {
	var l int
	_ = l
	if m.Times != 0 {
		n += 1 + sovBetting(uint64(m.Times))
	}
	if m.State != 0 {
		n += 1 + sovBetting(uint64(m.State))
	}
	return n
}

func (m *JackpotInfo) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Odds != 0 {
		n += 5
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	return n
}

func (m *CBetting) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	return n
}

func (m *SBetting) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	if m.Error != 0 {
		n += 1 + sovBetting(uint64(m.Error))
	}
	return n
}

func (m *SPushJackpot) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovBetting(uint64(l))
		}
	}
	return n
}

func (m *Jackpot) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	return n
}

func (m *SPushBetting) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovBetting(uint64(e))
		}
		n += 1 + sovBetting(uint64(l)) + l
	}
	if m.Niu != 0 {
		n += 1 + sovBetting(uint64(m.Niu))
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovBetting(uint64(l))
		}
	}
	if len(m.Info) > 0 {
		for _, e := range m.Info {
			l = e.Size()
			n += 1 + l + sovBetting(uint64(l))
		}
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBetting(uint64(l))
	}
	return n
}

func (m *JackpotOver) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Win {
		n += 2
	}
	if m.Odds != 0 {
		n += 5
	}
	if m.Count != 0 {
		n += 1 + sovBetting(uint64(m.Count))
	}
	return n
}

func (m *JackpotSelf) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Ante != 0 {
		n += 1 + sovBetting(uint64(m.Ante))
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	return n
}

func (m *SPushNewBetting) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovBetting(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBetting(uint64(l))
	}
	return n
}

func (m *CBettingRecord) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	if m.Page != 0 {
		n += 1 + sovBetting(uint64(m.Page))
	}
	return n
}

func (m *SBettingRecord) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBetting(uint64(m.Code))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovBetting(uint64(l))
		}
	}
	return n
}

func (m *RecordBettings) Size() (n int) {
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovBetting(uint64(l))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovBetting(uint64(e))
		}
		n += 1 + sovBetting(uint64(l)) + l
	}
	if m.Niu != 0 {
		n += 1 + sovBetting(uint64(m.Niu))
	}
	if len(m.Seats) > 0 {
		l = 0
		for _, e := range m.Seats {
			l += sovBetting(uint64(e))
		}
		n += 1 + sovBetting(uint64(l)) + l
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovBetting(uint64(l))
		}
	}
	return n
}

func (m *RecordBetting) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovBetting(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 1 + sovBetting(uint64(m.Number))
	}
	return n
}

func sovBetting(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBetting(x uint64) (n int) {
	return sovBetting(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CBettingInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CBettingInfo{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SBettingInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SBettingInfo{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Betting", "Betting", 1) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "JackpotInfo", "JackpotInfo", 1) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Betting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Betting{`,
		`Times:` + fmt.Sprintf("%v", this.Times) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JackpotInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JackpotInfo{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Odds:` + fmt.Sprintf("%v", this.Odds) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CBetting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CBetting{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SBetting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SBetting{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SPushJackpot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SPushJackpot{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "Jackpot", "Jackpot", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Jackpot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Jackpot{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SPushBetting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SPushBetting{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Niu:` + fmt.Sprintf("%v", this.Niu) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "JackpotSelf", "JackpotSelf", 1) + `,`,
		`Info:` + strings.Replace(fmt.Sprintf("%v", this.Info), "JackpotOver", "JackpotOver", 1) + `,`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Betting", "Betting", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JackpotOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JackpotOver{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Win:` + fmt.Sprintf("%v", this.Win) + `,`,
		`Odds:` + fmt.Sprintf("%v", this.Odds) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JackpotSelf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JackpotSelf{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Ante:` + fmt.Sprintf("%v", this.Ante) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SPushNewBetting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SPushNewBetting{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Betting", "Betting", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CBettingRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CBettingRecord{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Page:` + fmt.Sprintf("%v", this.Page) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SBettingRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SBettingRecord{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "RecordBettings", "RecordBettings", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecordBettings) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecordBettings{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Niu:` + fmt.Sprintf("%v", this.Niu) + `,`,
		`Seats:` + fmt.Sprintf("%v", this.Seats) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`List:` + strings.Replace(fmt.Sprintf("%v", this.List), "RecordBetting", "RecordBetting", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RecordBetting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RecordBetting{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringBetting(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CBettingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CBettingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CBettingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SBettingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SBettingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SBettingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Betting{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &JackpotInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (ErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Betting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Betting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Betting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JackpotInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JackpotInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JackpotInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Odds", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Odds = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CBetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CBetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CBetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SBetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SBetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SBetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (ErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SPushJackpot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SPushJackpot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SPushJackpot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &Jackpot{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Jackpot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Jackpot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Jackpot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SPushBetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SPushBetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SPushBetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBetting
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBetting
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Niu", wireType)
			}
			m.Niu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Niu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &JackpotSelf{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info, &JackpotOver{})
			if err := m.Info[len(m.Info)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Betting{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JackpotOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JackpotOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JackpotOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Odds", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Odds = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JackpotSelf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JackpotSelf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JackpotSelf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SPushNewBetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SPushNewBetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SPushNewBetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Betting{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CBettingRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CBettingRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CBettingRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SBettingRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SBettingRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SBettingRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecordBettings{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordBettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordBettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordBettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBetting
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBetting
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Niu", wireType)
			}
			m.Niu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Niu |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Seats = append(m.Seats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBetting
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBetting
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Seats = append(m.Seats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Seats", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBetting
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &RecordBetting{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordBetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordBetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordBetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBetting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBetting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBetting(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBetting
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBetting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBetting
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBetting
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBetting(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBetting = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBetting   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("betting.proto", fileDescriptorBetting) }

var fileDescriptorBetting = []byte{
	// 597 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xbd, 0x8e, 0xd3, 0x40,
	0x10, 0xce, 0xda, 0x71, 0x2e, 0x4c, 0x7e, 0xee, 0xb0, 0x4e, 0xc8, 0xa2, 0x58, 0x82, 0x23, 0x50,
	0x0a, 0x94, 0xe2, 0x10, 0x12, 0x12, 0xdd, 0x45, 0x14, 0x9c, 0xf8, 0xd3, 0xa6, 0x46, 0xc2, 0x89,
	0x37, 0x87, 0xc5, 0xc5, 0x1b, 0xd9, 0x1b, 0x8e, 0x92, 0x47, 0xe0, 0x1d, 0x10, 0x12, 0x8f, 0x42,
	0x79, 0x74, 0x94, 0xc4, 0x34, 0x94, 0xf7, 0x08, 0x68, 0xd6, 0x1b, 0x67, 0x43, 0x62, 0x02, 0x88,
	0x6e, 0xc6, 0xb3, 0xf3, 0xf3, 0x7d, 0xf3, 0xed, 0x1a, 0x5a, 0x23, 0x2e, 0x65, 0x14, 0x9f, 0xf6,
	0x67, 0x89, 0x90, 0xc2, 0xb5, 0x66, 0xa3, 0xeb, 0x30, 0x16, 0x21, 0xcf, 0x7d, 0xdf, 0x87, 0xe6,
	0xe0, 0x38, 0x3f, 0xf1, 0x28, 0x9e, 0x08, 0xd7, 0x85, 0x2a, 0x46, 0x3d, 0xd2, 0x21, 0xbd, 0x16,
	0x53, 0xb6, 0xff, 0x91, 0x40, 0x73, 0xb8, 0xe3, 0x90, 0x7b, 0x08, 0x4e, 0x14, 0x87, 0xfc, 0xad,
	0x67, 0x75, 0x48, 0xef, 0x0a, 0xcb, 0x1d, 0xb7, 0x0b, 0xb5, 0x54, 0x06, 0x72, 0x9e, 0x7a, 0x76,
	0x87, 0xf4, 0x1a, 0x47, 0x8d, 0xfe, 0x6c, 0xd4, 0xd7, 0xa5, 0x98, 0x0e, 0xb9, 0x5d, 0xa8, 0x9e,
	0x45, 0xa9, 0xf4, 0xaa, 0x1d, 0xbb, 0xd7, 0x38, 0xda, 0xc7, 0x23, 0x27, 0xc1, 0xf8, 0xf5, 0x4c,
	0x48, 0xec, 0xc6, 0x54, 0xd0, 0xbd, 0x09, 0x0e, 0x4f, 0x12, 0x91, 0x78, 0x4e, 0x87, 0xf4, 0xda,
	0x79, 0xa1, 0x87, 0x49, 0x32, 0x10, 0x21, 0x67, 0x79, 0xc4, 0xbf, 0x07, 0x7b, 0xba, 0x34, 0x4e,
	0x23, 0xa3, 0x29, 0x4f, 0xf5, 0x88, 0xb9, 0x83, 0x5f, 0xb1, 0x25, 0x57, 0x33, 0xb6, 0x58, 0xee,
	0xf8, 0x4f, 0xa0, 0x61, 0xb4, 0x43, 0x70, 0x29, 0x0f, 0xe4, 0x12, 0x1c, 0xda, 0xf8, 0x4d, 0x84,
	0x61, 0xaa, 0xf2, 0x2c, 0xa6, 0x6c, 0xf7, 0x1a, 0xd4, 0xe2, 0xf9, 0x74, 0xc4, 0x13, 0x05, 0xad,
	0xc5, 0xb4, 0xe7, 0x9f, 0x40, 0x7d, 0xc9, 0xe8, 0x56, 0xa2, 0x96, 0xf5, 0x2d, 0xa3, 0x7e, 0x59,
	0xad, 0x29, 0xd4, 0x87, 0xff, 0xa9, 0xd6, 0x8a, 0xc0, 0x6a, 0x29, 0x81, 0x03, 0x68, 0x0e, 0x9f,
	0xcf, 0xd3, 0x57, 0x9a, 0x8e, 0xad, 0x2d, 0x6f, 0xe8, 0x65, 0x59, 0x6a, 0x59, 0x0d, 0x63, 0x59,
	0xf9, 0xa2, 0x70, 0x0b, 0x46, 0xfe, 0x06, 0x95, 0xab, 0xf1, 0xac, 0x35, 0xa8, 0x5f, 0x88, 0x6e,
	0xfe, 0x3b, 0xbc, 0x87, 0xe0, 0x8c, 0x83, 0x44, 0x2d, 0xc2, 0xc6, 0x05, 0x2a, 0xc7, 0x3d, 0x00,
	0x3b, 0x8e, 0xe6, 0x1a, 0x2e, 0x9a, 0x46, 0x13, 0x04, 0xeb, 0x14, 0x1c, 0x2c, 0x95, 0xe6, 0x6c,
	0x28, 0x6d, 0xc8, 0xcf, 0x26, 0x5a, 0x69, 0x5d, 0xa8, 0x46, 0xf1, 0x44, 0x78, 0xb5, 0x8d, 0x43,
	0xcf, 0xde, 0xf0, 0x84, 0xa9, 0xa0, 0x21, 0xec, 0xbd, 0x52, 0x61, 0xfb, 0x2f, 0x0a, 0x65, 0x61,
	0xe6, 0x56, 0x3a, 0x0e, 0xc0, 0x3e, 0x8f, 0x62, 0xc5, 0x45, 0x9d, 0xa1, 0x59, 0x68, 0xcd, 0x36,
	0xb4, 0x86, 0xb8, 0xc5, 0x3c, 0x96, 0x0a, 0x0e, 0xe2, 0x46, 0xc7, 0x10, 0x2e, 0x4e, 0x5f, 0x26,
	0xdc, 0x20, 0x2e, 0x04, 0xaf, 0xec, 0x5f, 0x04, 0x52, 0x90, 0xe3, 0xbf, 0x84, 0x7d, 0xb5, 0x80,
	0xa7, 0xfc, 0x7c, 0xc7, 0x0e, 0xfe, 0xf1, 0xa2, 0xfb, 0xf7, 0xa1, 0xbd, 0xbc, 0x1a, 0x8c, 0x8f,
	0x45, 0x12, 0x96, 0x89, 0x7a, 0x16, 0x9c, 0x16, 0x33, 0xa3, 0xed, 0x3f, 0x86, 0xf6, 0x70, 0x77,
	0xe6, 0xed, 0x35, 0x6d, 0xba, 0x38, 0x42, 0x7e, 0x5a, 0xa7, 0xa6, 0x5a, 0xa2, 0x1f, 0x08, 0xb4,
	0xd7, 0x03, 0x2b, 0x54, 0xc4, 0x44, 0xf5, 0xa7, 0x7a, 0xc3, 0x87, 0x85, 0x07, 0x32, 0x55, 0x4f,
	0x18, 0x3e, 0x2c, 0xe8, 0x18, 0x44, 0x3b, 0x6b, 0x2a, 0xbc, 0xa5, 0xc7, 0xcc, 0x05, 0x76, 0x75,
	0x63, 0x4c, 0x3d, 0xe5, 0x03, 0x68, 0xad, 0x7d, 0xfe, 0x9b, 0xeb, 0x74, 0x7c, 0xe7, 0x62, 0x41,
	0x2b, 0x5f, 0x17, 0xb4, 0x72, 0xb9, 0xa0, 0xe4, 0x5d, 0x46, 0xc9, 0xa7, 0x8c, 0x92, 0xcf, 0x19,
	0x25, 0x17, 0x19, 0x25, 0xdf, 0x32, 0x4a, 0x7e, 0x64, 0xb4, 0x72, 0x99, 0x51, 0xf2, 0xfe, 0x3b,
	0xad, 0x8c, 0x6a, 0xea, 0x67, 0x70, 0xf7, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0xab, 0x88, 0x73,
	0xba, 0x2d, 0x06, 0x00, 0x00,
}
