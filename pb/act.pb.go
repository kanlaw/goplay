// Code generated by protoc-gen-gogo.
// source: act.proto
// DO NOT EDIT!

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		act.proto
		betting.proto
		buy.proto
		chat.proto
		classic.proto
		code.proto
		dan.proto
		data.proto
		free.proto
		logger.proto
		login.proto
		lottery.proto
		mail.proto
		niu.proto
		pay.proto
		phz.proto
		prize.proto
		protos.proto
		pub.proto
		robot.proto
		role.proto
		room.proto
		user.proto
		vo.proto
		web.proto

	It has these top-level messages:
		NewMail
		NewMailList
		DeleteMail
		GetMailItem
		BuildAgent
		BuiltAgent
		BankGive
		BankGave
		BetsOn
		BetsRecord
		SetOdds
		BetsTimeout
		BetsResult
		BetsPrize
		CBettingInfo
		SBettingInfo
		Betting
		JackpotInfo
		CBetting
		SBetting
		SPushJackpot
		Jackpot
		SPushBetting
		JackpotOver
		JackpotSelf
		SPushNewBetting
		CBettingRecord
		SBettingRecord
		RecordBettings
		RecordBetting
		CBuy
		SBuy
		CWxpayOrder
		SWxpayOrder
		CWxpayQuery
		SWxpayQuery
		CApplePay
		SApplePay
		CShop
		SShop
		Shop
		CChatText
		SChatText
		CChatVoice
		SChatVoice
		SBroadcast
		CNotice
		SNotice
		Notice
		CEnterClassicRoom
		SEnterClassicRoom
		SClassicGameover
		CGetPrize
		SGetPrize
		CPrizeCards
		SPrizeCards
		CDanInfo
		SDanInfo
		CQualifying
		SQualifying
		CDanRanking
		SDanRanking
		SDanNotice
		CEnterFreeRoom
		SEnterFreeRoom
		SFreeCamein
		CFreeDealer
		SFreeDealer
		CDealerList
		SDealerList
		CFreeSit
		SFreeSit
		CFreeBet
		SFreeBet
		SFreeGamestart
		SFreeGameover
		CFreeTrend
		SFreeTrend
		LogRegist
		LogLogin
		LogLogout
		LogDiamond
		LogCoin
		LogBuildAgency
		LogOnline
		LogSetHand
		CLogin
		SLogin
		CRegist
		SRegist
		CWxLogin
		SWxLogin
		SLoginOut
		CLotteryInfo
		SLotteryInfo
		Lottery
		CLottery
		SLottery
		SMailNotice
		CMailList
		SMailList
		CDeleteMail
		SDeleteMail
		CGetMailItem
		SGetMailItem
		Items
		MailList
		CEnterRoom
		SEnterRoom
		CCreateRoom
		SCreateRoom
		SCamein
		SDraw
		CDealer
		SDealer
		SPushDealer
		CBet
		SBet
		CNiu
		SNiu
		SGameover
		CGameRecord
		SGameRecord
		ApplePay
		ApplePaid
		WxpayCallback
		WxpayGoods
		CEnterZiRoom
		SEnterZiRoom
		CCreateZiRoom
		SCreateZiRoom
		SZiCamein
		SZiGameover
		CZiGameRecord
		SZiGameRecord
		SPushDeal
		SPushDealerDeal
		SPushDealerBu
		SPushPaoHu
		SPushDraw
		CPushDiscard
		SPushDiscard
		SPushAuto
		COperate
		SOperate
		SPushStatus
		CPrizeList
		SPrizeList
		CPrizeDraw
		SPrizeDraw
		CPrizeBox
		SPrizeBox
		Prize
		CBankrupts
		SBankrupts
		CClassicList
		SClassicList
		Classic
		CVipList
		SVipList
		Vip
		SPushVip
		Request
		Response
		GateConnect
		GateConnected
		GateDisconnect
		GateDisconnected
		HallConnect
		HallConnected
		ServeStop
		ServeStoped
		DanSeason
		DanRanking
		DanTaskList
		DanList
		DanInfo
		DanCombat
		RobotMsg
		RobotLogin
		RobotReLogin
		RobotLogout
		SetLogin
		SetLogined
		LoginGate
		LoginedGate
		LoginHall
		LoginedHall
		Login
		Logined
		LoginElse
		LoginedElse
		Logout
		Logouted
		SyncUser
		ChangeCurrency
		GetUserid
		GotUserid
		GetUniqueid
		GotUniqueid
		RoleLogin
		RoleLogined
		RoleRegist
		RoleRegisted
		WxLogin
		WxLogined
		GetUserData
		GotUserData
		CLeave
		SLeave
		CKick
		SKick
		CReady
		SReady
		CLaunchVote
		SLaunchVote
		CVote
		SVote
		SVoteResult
		SPubDraw
		CRoomList
		SRoomList
		CConfig
		SConfig
		CUserData
		SUserData
		CGetCurrency
		SGetCurrency
		CBuildAgent
		SBuildAgent
		SPushCurrency
		CBank
		SBank
		CPing
		SPing
		UserData
		UserInfo
		RoomInfo
		Activity
		VipInfo
		RoomUser
		RoomData
		RoomBets
		FreeUser
		FreeRoom
		RoomOver
		FreeRoomOver
		RoomScore
		ClassicOver
		OverList
		RoomVote
		RecordList
		DealerList
		FreeTrendList
		FreeTrend
		PrizeCard
		RoomCard
		RoomSeat
		ZiRoomOver
		DanOver
		ZiRoomRound
		ZiRecordList
		ZiRoomInfo
		SyncConfig
*/
package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 新邮件
type NewMail struct {
	From    string `protobuf:"bytes,1,opt,name=From,proto3" json:"From,omitempty"`
	To      string `protobuf:"bytes,2,opt,name=To,proto3" json:"To,omitempty"`
	Content string `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *NewMail) Reset()                    { *m = NewMail{} }
func (*NewMail) ProtoMessage()               {}
func (*NewMail) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{0} }

func (m *NewMail) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *NewMail) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *NewMail) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// 新邮件列表
type NewMailList struct {
	Maxid  string `protobuf:"bytes,1,opt,name=Maxid,proto3" json:"Maxid,omitempty"`
	Userid string `protobuf:"bytes,2,opt,name=Userid,proto3" json:"Userid,omitempty"`
}

func (m *NewMailList) Reset()                    { *m = NewMailList{} }
func (*NewMailList) ProtoMessage()               {}
func (*NewMailList) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{1} }

func (m *NewMailList) GetMaxid() string {
	if m != nil {
		return m.Maxid
	}
	return ""
}

func (m *NewMailList) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

// 删除邮件
type DeleteMail struct {
	Id     string `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Userid string `protobuf:"bytes,2,opt,name=Userid,proto3" json:"Userid,omitempty"`
}

func (m *DeleteMail) Reset()                    { *m = DeleteMail{} }
func (*DeleteMail) ProtoMessage()               {}
func (*DeleteMail) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{2} }

func (m *DeleteMail) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeleteMail) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

// 收取附件
type GetMailItem struct {
	Id     string `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Userid string `protobuf:"bytes,2,opt,name=Userid,proto3" json:"Userid,omitempty"`
}

func (m *GetMailItem) Reset()                    { *m = GetMailItem{} }
func (*GetMailItem) ProtoMessage()               {}
func (*GetMailItem) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{3} }

func (m *GetMailItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetMailItem) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

// 绑定代理id
type BuildAgent struct {
	Userid string `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Agent  string `protobuf:"bytes,2,opt,name=Agent,proto3" json:"Agent,omitempty"`
	Uid    string `protobuf:"bytes,3,opt,name=Uid,proto3" json:"Uid,omitempty"`
}

func (m *BuildAgent) Reset()                    { *m = BuildAgent{} }
func (*BuildAgent) ProtoMessage()               {}
func (*BuildAgent) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{4} }

func (m *BuildAgent) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BuildAgent) GetAgent() string {
	if m != nil {
		return m.Agent
	}
	return ""
}

func (m *BuildAgent) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

type BuiltAgent struct {
	Result uint32 `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
	Agent  string `protobuf:"bytes,2,opt,name=Agent,proto3" json:"Agent,omitempty"`
}

func (m *BuiltAgent) Reset()                    { *m = BuiltAgent{} }
func (*BuiltAgent) ProtoMessage()               {}
func (*BuiltAgent) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{5} }

func (m *BuiltAgent) GetResult() uint32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *BuiltAgent) GetAgent() string {
	if m != nil {
		return m.Agent
	}
	return ""
}

// 银行操作
type BankGive struct {
	Userid string `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Amount uint32 `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *BankGive) Reset()                    { *m = BankGive{} }
func (*BankGive) ProtoMessage()               {}
func (*BankGive) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{6} }

func (m *BankGive) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BankGive) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type BankGave struct {
	Userid string  `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Amount uint32  `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
	Coin   uint32  `protobuf:"varint,3,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Error  ErrCode `protobuf:"varint,4,opt,name=error,proto3,enum=pb.ErrCode" json:"error,omitempty"`
}

func (m *BankGave) Reset()                    { *m = BankGave{} }
func (*BankGave) ProtoMessage()               {}
func (*BankGave) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{7} }

func (m *BankGave) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BankGave) GetAmount() uint32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *BankGave) GetCoin() uint32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *BankGave) GetError() ErrCode {
	if m != nil {
		return m.Error
	}
	return OK
}

// 投注操作
type BetsOn struct {
	Userid string `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Seat   uint32 `protobuf:"varint,2,opt,name=Seat,proto3" json:"Seat,omitempty"`
	Number uint32 `protobuf:"varint,3,opt,name=Number,proto3" json:"Number,omitempty"`
}

func (m *BetsOn) Reset()                    { *m = BetsOn{} }
func (*BetsOn) ProtoMessage()               {}
func (*BetsOn) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{8} }

func (m *BetsOn) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BetsOn) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *BetsOn) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 投注记录操作
type BetsRecord struct {
	Userid string `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Page   uint32 `protobuf:"varint,2,opt,name=Page,proto3" json:"Page,omitempty"`
}

func (m *BetsRecord) Reset()                    { *m = BetsRecord{} }
func (*BetsRecord) ProtoMessage()               {}
func (*BetsRecord) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{9} }

func (m *BetsRecord) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BetsRecord) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

// 投注设置
type SetOdds struct {
	Seat   uint32  `protobuf:"varint,1,opt,name=Seat,proto3" json:"Seat,omitempty"`
	Number float32 `protobuf:"fixed32,2,opt,name=Number,proto3" json:"Number,omitempty"`
}

func (m *SetOdds) Reset()                    { *m = SetOdds{} }
func (*SetOdds) ProtoMessage()               {}
func (*SetOdds) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{10} }

func (m *SetOdds) GetSeat() uint32 {
	if m != nil {
		return m.Seat
	}
	return 0
}

func (m *SetOdds) GetNumber() float32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// 投注超时
type BetsTimeout struct {
	Timer uint32 `protobuf:"varint,1,opt,name=Timer,proto3" json:"Timer,omitempty"`
}

func (m *BetsTimeout) Reset()                    { *m = BetsTimeout{} }
func (*BetsTimeout) ProtoMessage()               {}
func (*BetsTimeout) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{11} }

func (m *BetsTimeout) GetTimer() uint32 {
	if m != nil {
		return m.Timer
	}
	return 0
}

// 投注结果
type BetsResult struct {
	Userid  string `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *BetsResult) Reset()                    { *m = BetsResult{} }
func (*BetsResult) ProtoMessage()               {}
func (*BetsResult) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{12} }

func (m *BetsResult) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BetsResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// 投注奖励
type BetsPrize struct {
	Userid  string `protobuf:"bytes,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	Type    int32  `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Diamond int32  `protobuf:"varint,3,opt,name=Diamond,proto3" json:"Diamond,omitempty"`
}

func (m *BetsPrize) Reset()                    { *m = BetsPrize{} }
func (*BetsPrize) ProtoMessage()               {}
func (*BetsPrize) Descriptor() ([]byte, []int) { return fileDescriptorAct, []int{13} }

func (m *BetsPrize) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *BetsPrize) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BetsPrize) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func init() {
	proto.RegisterType((*NewMail)(nil), "pb.NewMail")
	proto.RegisterType((*NewMailList)(nil), "pb.NewMailList")
	proto.RegisterType((*DeleteMail)(nil), "pb.DeleteMail")
	proto.RegisterType((*GetMailItem)(nil), "pb.GetMailItem")
	proto.RegisterType((*BuildAgent)(nil), "pb.BuildAgent")
	proto.RegisterType((*BuiltAgent)(nil), "pb.BuiltAgent")
	proto.RegisterType((*BankGive)(nil), "pb.BankGive")
	proto.RegisterType((*BankGave)(nil), "pb.BankGave")
	proto.RegisterType((*BetsOn)(nil), "pb.BetsOn")
	proto.RegisterType((*BetsRecord)(nil), "pb.BetsRecord")
	proto.RegisterType((*SetOdds)(nil), "pb.SetOdds")
	proto.RegisterType((*BetsTimeout)(nil), "pb.BetsTimeout")
	proto.RegisterType((*BetsResult)(nil), "pb.BetsResult")
	proto.RegisterType((*BetsPrize)(nil), "pb.BetsPrize")
}
func (this *NewMail) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewMail)
	if !ok {
		that2, ok := that.(NewMail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.From != that1.From {
		return false
	}
	if this.To != that1.To {
		return false
	}
	if this.Content != that1.Content {
		return false
	}
	return true
}
func (this *NewMailList) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewMailList)
	if !ok {
		that2, ok := that.(NewMailList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Maxid != that1.Maxid {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	return true
}
func (this *DeleteMail) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DeleteMail)
	if !ok {
		that2, ok := that.(DeleteMail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	return true
}
func (this *GetMailItem) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GetMailItem)
	if !ok {
		that2, ok := that.(GetMailItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	return true
}
func (this *BuildAgent) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BuildAgent)
	if !ok {
		that2, ok := that.(BuildAgent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Agent != that1.Agent {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	return true
}
func (this *BuiltAgent) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BuiltAgent)
	if !ok {
		that2, ok := that.(BuiltAgent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if this.Agent != that1.Agent {
		return false
	}
	return true
}
func (this *BankGive) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BankGive)
	if !ok {
		that2, ok := that.(BankGive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	return true
}
func (this *BankGave) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BankGave)
	if !ok {
		that2, ok := that.(BankGave)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *BetsOn) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BetsOn)
	if !ok {
		that2, ok := that.(BetsOn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *BetsRecord) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BetsRecord)
	if !ok {
		that2, ok := that.(BetsRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Page != that1.Page {
		return false
	}
	return true
}
func (this *SetOdds) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SetOdds)
	if !ok {
		that2, ok := that.(SetOdds)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Seat != that1.Seat {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	return true
}
func (this *BetsTimeout) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BetsTimeout)
	if !ok {
		that2, ok := that.(BetsTimeout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Timer != that1.Timer {
		return false
	}
	return true
}
func (this *BetsResult) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BetsResult)
	if !ok {
		that2, ok := that.(BetsResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *BetsPrize) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BetsPrize)
	if !ok {
		that2, ok := that.(BetsPrize)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Userid != that1.Userid {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Diamond != that1.Diamond {
		return false
	}
	return true
}
func (this *NewMail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.NewMail{")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NewMailList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.NewMailList{")
	s = append(s, "Maxid: "+fmt.Sprintf("%#v", this.Maxid)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteMail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.DeleteMail{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetMailItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.GetMailItem{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuildAgent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.BuildAgent{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Agent: "+fmt.Sprintf("%#v", this.Agent)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuiltAgent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.BuiltAgent{")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "Agent: "+fmt.Sprintf("%#v", this.Agent)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BankGive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.BankGive{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BankGave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pb.BankGave{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BetsOn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.BetsOn{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BetsRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.BetsRecord{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Page: "+fmt.Sprintf("%#v", this.Page)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SetOdds) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.SetOdds{")
	s = append(s, "Seat: "+fmt.Sprintf("%#v", this.Seat)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BetsTimeout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pb.BetsTimeout{")
	s = append(s, "Timer: "+fmt.Sprintf("%#v", this.Timer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BetsResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pb.BetsResult{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BetsPrize) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pb.BetsPrize{")
	s = append(s, "Userid: "+fmt.Sprintf("%#v", this.Userid)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Diamond: "+fmt.Sprintf("%#v", this.Diamond)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAct(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NewMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewMail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *NewMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewMailList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Maxid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Maxid)))
		i += copy(dAtA[i:], m.Maxid)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	return i, nil
}

func (m *DeleteMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	return i, nil
}

func (m *GetMailItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Userid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	return i, nil
}

func (m *BuildAgent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildAgent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Agent) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Agent)))
		i += copy(dAtA[i:], m.Agent)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	return i, nil
}

func (m *BuiltAgent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuiltAgent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Result))
	}
	if len(m.Agent) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Agent)))
		i += copy(dAtA[i:], m.Agent)
	}
	return i, nil
}

func (m *BankGive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankGive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *BankGave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BankGave) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Amount))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Coin))
	}
	if m.Error != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *BetsOn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetsOn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Seat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *BetsRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetsRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Page != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *SetOdds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetOdds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seat != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Seat))
	}
	if m.Number != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Act(dAtA, i, uint32(math.Float32bits(float32(m.Number))))
	}
	return i, nil
}

func (m *BetsTimeout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetsTimeout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Timer))
	}
	return i, nil
}

func (m *BetsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *BetsPrize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BetsPrize) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Userid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAct(dAtA, i, uint64(len(m.Userid)))
		i += copy(dAtA[i:], m.Userid)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Type))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAct(dAtA, i, uint64(m.Diamond))
	}
	return i, nil
}

func encodeFixed64Act(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Act(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAct(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NewMail) Size() (n int) {
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *NewMailList) Size() (n int) {
	var l int
	_ = l
	l = len(m.Maxid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *DeleteMail) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *GetMailItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *BuildAgent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Agent)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *BuiltAgent) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovAct(uint64(m.Result))
	}
	l = len(m.Agent)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *BankGive) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovAct(uint64(m.Amount))
	}
	return n
}

func (m *BankGave) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovAct(uint64(m.Amount))
	}
	if m.Coin != 0 {
		n += 1 + sovAct(uint64(m.Coin))
	}
	if m.Error != 0 {
		n += 1 + sovAct(uint64(m.Error))
	}
	return n
}

func (m *BetsOn) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	if m.Seat != 0 {
		n += 1 + sovAct(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 1 + sovAct(uint64(m.Number))
	}
	return n
}

func (m *BetsRecord) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	if m.Page != 0 {
		n += 1 + sovAct(uint64(m.Page))
	}
	return n
}

func (m *SetOdds) Size() (n int) {
	var l int
	_ = l
	if m.Seat != 0 {
		n += 1 + sovAct(uint64(m.Seat))
	}
	if m.Number != 0 {
		n += 5
	}
	return n
}

func (m *BetsTimeout) Size() (n int) {
	var l int
	_ = l
	if m.Timer != 0 {
		n += 1 + sovAct(uint64(m.Timer))
	}
	return n
}

func (m *BetsResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	return n
}

func (m *BetsPrize) Size() (n int) {
	var l int
	_ = l
	l = len(m.Userid)
	if l > 0 {
		n += 1 + l + sovAct(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAct(uint64(m.Type))
	}
	if m.Diamond != 0 {
		n += 1 + sovAct(uint64(m.Diamond))
	}
	return n
}

func sovAct(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAct(x uint64) (n int) {
	return sovAct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NewMail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewMail{`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewMailList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewMailList{`,
		`Maxid:` + fmt.Sprintf("%v", this.Maxid) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteMail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteMail{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetMailItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetMailItem{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BuildAgent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BuildAgent{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Agent:` + fmt.Sprintf("%v", this.Agent) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BuiltAgent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BuiltAgent{`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`Agent:` + fmt.Sprintf("%v", this.Agent) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BankGive) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BankGive{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BankGave) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BankGave{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BetsOn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BetsOn{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BetsRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BetsRecord{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Page:` + fmt.Sprintf("%v", this.Page) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SetOdds) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SetOdds{`,
		`Seat:` + fmt.Sprintf("%v", this.Seat) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BetsTimeout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BetsTimeout{`,
		`Timer:` + fmt.Sprintf("%v", this.Timer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BetsResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BetsResult{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BetsPrize) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BetsPrize{`,
		`Userid:` + fmt.Sprintf("%v", this.Userid) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Diamond:` + fmt.Sprintf("%v", this.Diamond) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAct(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NewMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildAgent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildAgent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildAgent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Agent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuiltAgent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuiltAgent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuiltAgent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Agent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankGive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankGive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankGive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BankGave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BankGave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BankGave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (ErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetsOn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetsOn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetsOn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetsRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetsRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetsRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetOdds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetOdds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetOdds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seat", wireType)
			}
			m.Seat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seat |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Number = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetsTimeout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetsTimeout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetsTimeout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			m.Timer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BetsPrize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BetsPrize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BetsPrize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAct
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Userid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAct
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAct
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAct(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAct = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAct   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("act.proto", fileDescriptorAct) }

var fileDescriptorAct = []byte{
	// 492 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xcd, 0x6e, 0x13, 0x31,
	0x14, 0x85, 0xe3, 0x69, 0x7e, 0xc8, 0x8d, 0x12, 0x21, 0x0b, 0x55, 0x23, 0x16, 0x56, 0x31, 0x9b,
	0x2e, 0x50, 0x16, 0x40, 0x25, 0x54, 0x24, 0xa4, 0x26, 0x85, 0x28, 0x52, 0xd2, 0x16, 0x37, 0x7d,
	0x80, 0x49, 0xe6, 0xaa, 0xb2, 0xc8, 0x8c, 0x83, 0xc7, 0xc3, 0xdf, 0x8a, 0x47, 0xe0, 0x31, 0x78,
	0x14, 0x96, 0x5d, 0xb2, 0x24, 0xc3, 0x86, 0x65, 0x1f, 0x01, 0xd9, 0xe3, 0x89, 0xba, 0x68, 0x2a,
	0xd8, 0x9d, 0xe3, 0xf8, 0x3b, 0xe7, 0x5e, 0x39, 0x03, 0xed, 0x68, 0x61, 0xfa, 0x2b, 0xad, 0x8c,
	0xa2, 0xc1, 0x6a, 0xfe, 0x10, 0x16, 0x2a, 0xc6, 0xd2, 0xf3, 0x11, 0xb4, 0x4e, 0xf0, 0xe3, 0x34,
	0x92, 0x4b, 0x4a, 0xa1, 0xfe, 0x46, 0xab, 0x24, 0x24, 0x7b, 0x64, 0xbf, 0x2d, 0x9c, 0xa6, 0x3d,
	0x08, 0x66, 0x2a, 0x0c, 0xdc, 0x49, 0x30, 0x53, 0x34, 0x84, 0xd6, 0x50, 0xa5, 0x06, 0x53, 0x13,
	0xee, 0xb8, 0xc3, 0xca, 0xf2, 0x97, 0xd0, 0xf1, 0x41, 0x13, 0x99, 0x19, 0xfa, 0x00, 0x1a, 0xd3,
	0xe8, 0x93, 0x8c, 0x7d, 0x5a, 0x69, 0xe8, 0x2e, 0x34, 0x2f, 0x32, 0xd4, 0x32, 0xf6, 0x91, 0xde,
	0xf1, 0xe7, 0x00, 0xc7, 0xb8, 0x44, 0x83, 0x6e, 0x90, 0x1e, 0x04, 0xe3, 0x0a, 0x0c, 0xc6, 0xdb,
	0xa9, 0x03, 0xe8, 0x8c, 0xd0, 0x58, 0x64, 0x6c, 0x30, 0xf9, 0x67, 0x6c, 0x02, 0x30, 0xc8, 0xe5,
	0x32, 0x3e, 0xba, 0xc4, 0xd4, 0xdc, 0xb8, 0x45, 0x6e, 0xde, 0xb2, 0x0b, 0xb8, 0x0b, 0x1e, 0x2e,
	0x0d, 0xbd, 0x0f, 0x3b, 0x17, 0x32, 0xf6, 0xbb, 0x5b, 0xc9, 0x0f, 0xcb, 0x34, 0xb3, 0x49, 0x13,
	0x98, 0xe5, 0x4b, 0xe3, 0xd2, 0xba, 0xc2, 0xbb, 0xdb, 0xd3, 0xf8, 0x21, 0xdc, 0x1b, 0x44, 0xe9,
	0xbb, 0x91, 0xfc, 0x80, 0x5b, 0xe7, 0xd8, 0x85, 0xe6, 0x51, 0xa2, 0x72, 0x8f, 0x76, 0x85, 0x77,
	0xfc, 0xbd, 0x67, 0xa3, 0xff, 0x67, 0xed, 0x4b, 0x0f, 0x95, 0x4c, 0xdd, 0x1a, 0x5d, 0xe1, 0x34,
	0x7d, 0x04, 0x0d, 0xd4, 0x5a, 0xe9, 0xb0, 0xbe, 0x47, 0xf6, 0x7b, 0x4f, 0x3b, 0xfd, 0xd5, 0xbc,
	0xff, 0x5a, 0xeb, 0xa1, 0x8a, 0x51, 0x94, 0xbf, 0xf0, 0x09, 0x34, 0x07, 0x68, 0xb2, 0xd3, 0x74,
	0x6b, 0x21, 0x85, 0xfa, 0x39, 0x46, 0x55, 0x9d, 0xd3, 0xf6, 0xee, 0x49, 0x9e, 0xcc, 0x51, 0xfb,
	0x3a, 0xef, 0xf8, 0x0b, 0x00, 0x9b, 0x26, 0x70, 0xa1, 0x74, 0x7c, 0x57, 0xe2, 0x59, 0x74, 0x89,
	0x55, 0xa2, 0xd5, 0xfc, 0x00, 0x5a, 0xe7, 0x68, 0x4e, 0xe3, 0x38, 0xdb, 0x14, 0x92, 0x5b, 0x0b,
	0x2d, 0x14, 0x6c, 0x0a, 0x1f, 0x43, 0xc7, 0x16, 0xce, 0x64, 0x82, 0x2a, 0x77, 0x4f, 0x62, 0xa5,
	0xf6, 0x6c, 0x69, 0xf8, 0xab, 0x6a, 0x2a, 0xf7, 0x6c, 0xdb, 0xa6, 0x0a, 0xa1, 0x35, 0xc5, 0x2c,
	0xab, 0x06, 0x6b, 0x8b, 0xca, 0xf2, 0xb7, 0xd0, 0xb6, 0xfc, 0x99, 0x96, 0x5f, 0xf0, 0xae, 0xa5,
	0x66, 0x9f, 0x57, 0x25, 0xdb, 0x10, 0x4e, 0xdb, 0xc8, 0x63, 0x19, 0x25, 0x2a, 0x2d, 0xff, 0x5d,
	0x0d, 0x51, 0xd9, 0xc1, 0x93, 0xab, 0x35, 0xab, 0xfd, 0x5c, 0xb3, 0xda, 0xf5, 0x9a, 0x91, 0xaf,
	0x05, 0x23, 0xdf, 0x0b, 0x46, 0x7e, 0x14, 0x8c, 0x5c, 0x15, 0x8c, 0xfc, 0x2a, 0x18, 0xf9, 0x53,
	0xb0, 0xda, 0x75, 0xc1, 0xc8, 0xb7, 0xdf, 0xac, 0x36, 0x6f, 0xba, 0xef, 0xfa, 0xd9, 0xdf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x88, 0x17, 0x94, 0xf5, 0xf4, 0x03, 0x00, 0x00,
}
